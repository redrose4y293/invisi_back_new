
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model Page
 * 
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model UploadAsset
 * 
 */
export type UploadAsset = $Result.DefaultSelection<Prisma.$UploadAssetPayload>
/**
 * Model Installation
 * 
 */
export type Installation = $Result.DefaultSelection<Prisma.$InstallationPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model AuditEvent
 * 
 */
export type AuditEvent = $Result.DefaultSelection<Prisma.$AuditEventPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Dealer
 * 
 */
export type Dealer = $Result.DefaultSelection<Prisma.$DealerPayload>
/**
 * Model FileAsset
 * 
 */
export type FileAsset = $Result.DefaultSelection<Prisma.$FileAssetPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model DealerUpload
 * 
 */
export type DealerUpload = $Result.DefaultSelection<Prisma.$DealerUploadPayload>
/**
 * Model TrainingEvent
 * 
 */
export type TrainingEvent = $Result.DefaultSelection<Prisma.$TrainingEventPayload>
/**
 * Model TrainingRegistration
 * 
 */
export type TrainingRegistration = $Result.DefaultSelection<Prisma.$TrainingRegistrationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  admin: 'admin',
  dealer: 'dealer',
  installer: 'installer',
  marketing: 'marketing',
  user: 'user'
};

export type Role = (typeof Role)[keyof typeof Role]


export const PageStatus: {
  draft: 'draft',
  published: 'published'
};

export type PageStatus = (typeof PageStatus)[keyof typeof PageStatus]


export const InstallStatus: {
  created: 'created',
  scheduled: 'scheduled',
  in_progress: 'in_progress',
  completed: 'completed',
  archived: 'archived'
};

export type InstallStatus = (typeof InstallStatus)[keyof typeof InstallStatus]


export const LeadType: {
  Prototype: 'Prototype',
  Dealer: 'Dealer',
  Media: 'Media',
  Other: 'Other'
};

export type LeadType = (typeof LeadType)[keyof typeof LeadType]


export const LeadStatus: {
  New: 'New',
  In_Review: 'In_Review',
  Qualified: 'Qualified',
  Closed: 'Closed'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const DealerStatus: {
  Pending: 'Pending',
  Active: 'Active',
  Suspended: 'Suspended'
};

export type DealerStatus = (typeof DealerStatus)[keyof typeof DealerStatus]


export const FileType: {
  PDF: 'PDF',
  Video: 'Video',
  Image: 'Image',
  Other: 'Other'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const FileCategory: {
  NDA: 'NDA',
  Spec: 'Spec',
  Report: 'Report',
  Marketing: 'Marketing'
};

export type FileCategory = (typeof FileCategory)[keyof typeof FileCategory]


export const FileVisibility: {
  Public: 'Public',
  Dealer: 'Dealer',
  Admin: 'Admin'
};

export type FileVisibility = (typeof FileVisibility)[keyof typeof FileVisibility]


export const ProductStatus: {
  Draft: 'Draft',
  Live: 'Live',
  Archived: 'Archived'
};

export type ProductStatus = (typeof ProductStatus)[keyof typeof ProductStatus]


export const DealerUploadStatus: {
  Pending: 'Pending',
  Approved: 'Approved',
  Rejected: 'Rejected'
};

export type DealerUploadStatus = (typeof DealerUploadStatus)[keyof typeof DealerUploadStatus]


export const TrainingMode: {
  Online: 'Online',
  On_site: 'On_site'
};

export type TrainingMode = (typeof TrainingMode)[keyof typeof TrainingMode]


export const TrainingStatus: {
  Draft: 'Draft',
  Live: 'Live',
  Archived: 'Archived'
};

export type TrainingStatus = (typeof TrainingStatus)[keyof typeof TrainingStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type PageStatus = $Enums.PageStatus

export const PageStatus: typeof $Enums.PageStatus

export type InstallStatus = $Enums.InstallStatus

export const InstallStatus: typeof $Enums.InstallStatus

export type LeadType = $Enums.LeadType

export const LeadType: typeof $Enums.LeadType

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type DealerStatus = $Enums.DealerStatus

export const DealerStatus: typeof $Enums.DealerStatus

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

export type FileCategory = $Enums.FileCategory

export const FileCategory: typeof $Enums.FileCategory

export type FileVisibility = $Enums.FileVisibility

export const FileVisibility: typeof $Enums.FileVisibility

export type ProductStatus = $Enums.ProductStatus

export const ProductStatus: typeof $Enums.ProductStatus

export type DealerUploadStatus = $Enums.DealerUploadStatus

export const DealerUploadStatus: typeof $Enums.DealerUploadStatus

export type TrainingMode = $Enums.TrainingMode

export const TrainingMode: typeof $Enums.TrainingMode

export type TrainingStatus = $Enums.TrainingStatus

export const TrainingStatus: typeof $Enums.TrainingStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs>;

  /**
   * `prisma.page`: Exposes CRUD operations for the **Page** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.page.findMany()
    * ```
    */
  get page(): Prisma.PageDelegate<ExtArgs>;

  /**
   * `prisma.uploadAsset`: Exposes CRUD operations for the **UploadAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UploadAssets
    * const uploadAssets = await prisma.uploadAsset.findMany()
    * ```
    */
  get uploadAsset(): Prisma.UploadAssetDelegate<ExtArgs>;

  /**
   * `prisma.installation`: Exposes CRUD operations for the **Installation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Installations
    * const installations = await prisma.installation.findMany()
    * ```
    */
  get installation(): Prisma.InstallationDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.auditEvent`: Exposes CRUD operations for the **AuditEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditEvents
    * const auditEvents = await prisma.auditEvent.findMany()
    * ```
    */
  get auditEvent(): Prisma.AuditEventDelegate<ExtArgs>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs>;

  /**
   * `prisma.dealer`: Exposes CRUD operations for the **Dealer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dealers
    * const dealers = await prisma.dealer.findMany()
    * ```
    */
  get dealer(): Prisma.DealerDelegate<ExtArgs>;

  /**
   * `prisma.fileAsset`: Exposes CRUD operations for the **FileAsset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileAssets
    * const fileAssets = await prisma.fileAsset.findMany()
    * ```
    */
  get fileAsset(): Prisma.FileAssetDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.dealerUpload`: Exposes CRUD operations for the **DealerUpload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DealerUploads
    * const dealerUploads = await prisma.dealerUpload.findMany()
    * ```
    */
  get dealerUpload(): Prisma.DealerUploadDelegate<ExtArgs>;

  /**
   * `prisma.trainingEvent`: Exposes CRUD operations for the **TrainingEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingEvents
    * const trainingEvents = await prisma.trainingEvent.findMany()
    * ```
    */
  get trainingEvent(): Prisma.TrainingEventDelegate<ExtArgs>;

  /**
   * `prisma.trainingRegistration`: Exposes CRUD operations for the **TrainingRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingRegistrations
    * const trainingRegistrations = await prisma.trainingRegistration.findMany()
    * ```
    */
  get trainingRegistration(): Prisma.TrainingRegistrationDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Session: 'Session',
    Page: 'Page',
    UploadAsset: 'UploadAsset',
    Installation: 'Installation',
    Report: 'Report',
    AuditEvent: 'AuditEvent',
    Lead: 'Lead',
    Dealer: 'Dealer',
    FileAsset: 'FileAsset',
    Product: 'Product',
    DealerUpload: 'DealerUpload',
    TrainingEvent: 'TrainingEvent',
    TrainingRegistration: 'TrainingRegistration'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "session" | "page" | "uploadAsset" | "installation" | "report" | "auditEvent" | "lead" | "dealer" | "fileAsset" | "product" | "dealerUpload" | "trainingEvent" | "trainingRegistration"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SessionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SessionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      Page: {
        payload: Prisma.$PagePayload<ExtArgs>
        fields: Prisma.PageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findFirst: {
            args: Prisma.PageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findMany: {
            args: Prisma.PageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          create: {
            args: Prisma.PageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          createMany: {
            args: Prisma.PageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          update: {
            args: Prisma.PageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          deleteMany: {
            args: Prisma.PageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          aggregate: {
            args: Prisma.PageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePage>
          }
          groupBy: {
            args: Prisma.PageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.PageFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.PageAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.PageCountArgs<ExtArgs>
            result: $Utils.Optional<PageCountAggregateOutputType> | number
          }
        }
      }
      UploadAsset: {
        payload: Prisma.$UploadAssetPayload<ExtArgs>
        fields: Prisma.UploadAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UploadAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UploadAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadAssetPayload>
          }
          findFirst: {
            args: Prisma.UploadAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UploadAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadAssetPayload>
          }
          findMany: {
            args: Prisma.UploadAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadAssetPayload>[]
          }
          create: {
            args: Prisma.UploadAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadAssetPayload>
          }
          createMany: {
            args: Prisma.UploadAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UploadAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadAssetPayload>
          }
          update: {
            args: Prisma.UploadAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadAssetPayload>
          }
          deleteMany: {
            args: Prisma.UploadAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UploadAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UploadAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UploadAssetPayload>
          }
          aggregate: {
            args: Prisma.UploadAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUploadAsset>
          }
          groupBy: {
            args: Prisma.UploadAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<UploadAssetGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UploadAssetFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UploadAssetAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UploadAssetCountArgs<ExtArgs>
            result: $Utils.Optional<UploadAssetCountAggregateOutputType> | number
          }
        }
      }
      Installation: {
        payload: Prisma.$InstallationPayload<ExtArgs>
        fields: Prisma.InstallationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstallationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstallationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallationPayload>
          }
          findFirst: {
            args: Prisma.InstallationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstallationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallationPayload>
          }
          findMany: {
            args: Prisma.InstallationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallationPayload>[]
          }
          create: {
            args: Prisma.InstallationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallationPayload>
          }
          createMany: {
            args: Prisma.InstallationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InstallationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallationPayload>
          }
          update: {
            args: Prisma.InstallationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallationPayload>
          }
          deleteMany: {
            args: Prisma.InstallationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstallationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InstallationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstallationPayload>
          }
          aggregate: {
            args: Prisma.InstallationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstallation>
          }
          groupBy: {
            args: Prisma.InstallationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstallationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.InstallationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.InstallationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.InstallationCountArgs<ExtArgs>
            result: $Utils.Optional<InstallationCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ReportFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ReportAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      AuditEvent: {
        payload: Prisma.$AuditEventPayload<ExtArgs>
        fields: Prisma.AuditEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findFirst: {
            args: Prisma.AuditEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          findMany: {
            args: Prisma.AuditEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>[]
          }
          create: {
            args: Prisma.AuditEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          createMany: {
            args: Prisma.AuditEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.AuditEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          update: {
            args: Prisma.AuditEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          deleteMany: {
            args: Prisma.AuditEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditEventPayload>
          }
          aggregate: {
            args: Prisma.AuditEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditEvent>
          }
          groupBy: {
            args: Prisma.AuditEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditEventGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.AuditEventFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.AuditEventAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.AuditEventCountArgs<ExtArgs>
            result: $Utils.Optional<AuditEventCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.LeadFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.LeadAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Dealer: {
        payload: Prisma.$DealerPayload<ExtArgs>
        fields: Prisma.DealerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerPayload>
          }
          findFirst: {
            args: Prisma.DealerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerPayload>
          }
          findMany: {
            args: Prisma.DealerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerPayload>[]
          }
          create: {
            args: Prisma.DealerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerPayload>
          }
          createMany: {
            args: Prisma.DealerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DealerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerPayload>
          }
          update: {
            args: Prisma.DealerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerPayload>
          }
          deleteMany: {
            args: Prisma.DealerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DealerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerPayload>
          }
          aggregate: {
            args: Prisma.DealerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDealer>
          }
          groupBy: {
            args: Prisma.DealerGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DealerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DealerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DealerCountArgs<ExtArgs>
            result: $Utils.Optional<DealerCountAggregateOutputType> | number
          }
        }
      }
      FileAsset: {
        payload: Prisma.$FileAssetPayload<ExtArgs>
        fields: Prisma.FileAssetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileAssetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileAssetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssetPayload>
          }
          findFirst: {
            args: Prisma.FileAssetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileAssetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssetPayload>
          }
          findMany: {
            args: Prisma.FileAssetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssetPayload>[]
          }
          create: {
            args: Prisma.FileAssetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssetPayload>
          }
          createMany: {
            args: Prisma.FileAssetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FileAssetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssetPayload>
          }
          update: {
            args: Prisma.FileAssetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssetPayload>
          }
          deleteMany: {
            args: Prisma.FileAssetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileAssetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FileAssetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileAssetPayload>
          }
          aggregate: {
            args: Prisma.FileAssetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileAsset>
          }
          groupBy: {
            args: Prisma.FileAssetGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileAssetGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.FileAssetFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.FileAssetAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.FileAssetCountArgs<ExtArgs>
            result: $Utils.Optional<FileAssetCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ProductFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ProductAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      DealerUpload: {
        payload: Prisma.$DealerUploadPayload<ExtArgs>
        fields: Prisma.DealerUploadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealerUploadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerUploadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealerUploadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerUploadPayload>
          }
          findFirst: {
            args: Prisma.DealerUploadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerUploadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealerUploadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerUploadPayload>
          }
          findMany: {
            args: Prisma.DealerUploadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerUploadPayload>[]
          }
          create: {
            args: Prisma.DealerUploadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerUploadPayload>
          }
          createMany: {
            args: Prisma.DealerUploadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DealerUploadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerUploadPayload>
          }
          update: {
            args: Prisma.DealerUploadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerUploadPayload>
          }
          deleteMany: {
            args: Prisma.DealerUploadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealerUploadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DealerUploadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealerUploadPayload>
          }
          aggregate: {
            args: Prisma.DealerUploadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDealerUpload>
          }
          groupBy: {
            args: Prisma.DealerUploadGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealerUploadGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.DealerUploadFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.DealerUploadAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.DealerUploadCountArgs<ExtArgs>
            result: $Utils.Optional<DealerUploadCountAggregateOutputType> | number
          }
        }
      }
      TrainingEvent: {
        payload: Prisma.$TrainingEventPayload<ExtArgs>
        fields: Prisma.TrainingEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEventPayload>
          }
          findFirst: {
            args: Prisma.TrainingEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEventPayload>
          }
          findMany: {
            args: Prisma.TrainingEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEventPayload>[]
          }
          create: {
            args: Prisma.TrainingEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEventPayload>
          }
          createMany: {
            args: Prisma.TrainingEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrainingEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEventPayload>
          }
          update: {
            args: Prisma.TrainingEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEventPayload>
          }
          deleteMany: {
            args: Prisma.TrainingEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingEventPayload>
          }
          aggregate: {
            args: Prisma.TrainingEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingEvent>
          }
          groupBy: {
            args: Prisma.TrainingEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingEventGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TrainingEventFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TrainingEventAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TrainingEventCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingEventCountAggregateOutputType> | number
          }
        }
      }
      TrainingRegistration: {
        payload: Prisma.$TrainingRegistrationPayload<ExtArgs>
        fields: Prisma.TrainingRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRegistrationPayload>
          }
          findFirst: {
            args: Prisma.TrainingRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRegistrationPayload>
          }
          findMany: {
            args: Prisma.TrainingRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRegistrationPayload>[]
          }
          create: {
            args: Prisma.TrainingRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRegistrationPayload>
          }
          createMany: {
            args: Prisma.TrainingRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TrainingRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRegistrationPayload>
          }
          update: {
            args: Prisma.TrainingRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.TrainingRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingRegistrationPayload>
          }
          aggregate: {
            args: Prisma.TrainingRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingRegistration>
          }
          groupBy: {
            args: Prisma.TrainingRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingRegistrationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TrainingRegistrationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TrainingRegistrationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TrainingRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingRegistrationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    sessions: number
    uploads: number
    pagesCreated: number
    pagesUpdated: number
    auditEvents: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    uploads?: boolean | UserCountOutputTypeCountUploadsArgs
    pagesCreated?: boolean | UserCountOutputTypeCountPagesCreatedArgs
    pagesUpdated?: boolean | UserCountOutputTypeCountPagesUpdatedArgs
    auditEvents?: boolean | UserCountOutputTypeCountAuditEventsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadAssetWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPagesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPagesUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
  }


  /**
   * Count Type InstallationCountOutputType
   */

  export type InstallationCountOutputType = {
    reports: number
  }

  export type InstallationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | InstallationCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * InstallationCountOutputType without action
   */
  export type InstallationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstallationCountOutputType
     */
    select?: InstallationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstallationCountOutputType without action
   */
  export type InstallationCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    displayName: string | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    displayName: number
    roles: number
    profile: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    displayName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    displayName?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    displayName?: true
    roles?: true
    profile?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    displayName: string
    roles: $Enums.Role[]
    profile: JsonValue | null
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    roles?: boolean
    profile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    uploads?: boolean | User$uploadsArgs<ExtArgs>
    pagesCreated?: boolean | User$pagesCreatedArgs<ExtArgs>
    pagesUpdated?: boolean | User$pagesUpdatedArgs<ExtArgs>
    auditEvents?: boolean | User$auditEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    displayName?: boolean
    roles?: boolean
    profile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    uploads?: boolean | User$uploadsArgs<ExtArgs>
    pagesCreated?: boolean | User$pagesCreatedArgs<ExtArgs>
    pagesUpdated?: boolean | User$pagesUpdatedArgs<ExtArgs>
    auditEvents?: boolean | User$auditEventsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      uploads: Prisma.$UploadAssetPayload<ExtArgs>[]
      pagesCreated: Prisma.$PagePayload<ExtArgs>[]
      pagesUpdated: Prisma.$PagePayload<ExtArgs>[]
      auditEvents: Prisma.$AuditEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      displayName: string
      roles: $Enums.Role[]
      profile: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany"> | Null>
    uploads<T extends User$uploadsArgs<ExtArgs> = {}>(args?: Subset<T, User$uploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadAssetPayload<ExtArgs>, T, "findMany"> | Null>
    pagesCreated<T extends User$pagesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$pagesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany"> | Null>
    pagesUpdated<T extends User$pagesUpdatedArgs<ExtArgs> = {}>(args?: Subset<T, User$pagesUpdatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany"> | Null>
    auditEvents<T extends User$auditEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly displayName: FieldRef<"User", 'String'>
    readonly roles: FieldRef<"User", 'Role[]'>
    readonly profile: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.uploads
   */
  export type User$uploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadAsset
     */
    select?: UploadAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadAssetInclude<ExtArgs> | null
    where?: UploadAssetWhereInput
    orderBy?: UploadAssetOrderByWithRelationInput | UploadAssetOrderByWithRelationInput[]
    cursor?: UploadAssetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UploadAssetScalarFieldEnum | UploadAssetScalarFieldEnum[]
  }

  /**
   * User.pagesCreated
   */
  export type User$pagesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * User.pagesUpdated
   */
  export type User$pagesUpdatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    where?: PageWhereInput
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    cursor?: PageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * User.auditEvents
   */
  export type User$auditEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    cursor?: AuditEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    userAgent: string | null
    ip: string | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    refreshToken: string | null
    userAgent: string | null
    ip: string | null
    createdAt: Date | null
    revokedAt: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    userId: number
    refreshToken: number
    userAgent: number
    ip: number
    createdAt: number
    revokedAt: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    userAgent?: true
    ip?: true
    createdAt?: true
    revokedAt?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    userAgent?: true
    ip?: true
    createdAt?: true
    revokedAt?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    userId?: true
    refreshToken?: true
    userAgent?: true
    ip?: true
    createdAt?: true
    revokedAt?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    userId: string
    refreshToken: string
    userAgent: string | null
    ip: string | null
    createdAt: Date
    revokedAt: Date | null
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    userAgent?: boolean
    ip?: boolean
    createdAt?: boolean
    revokedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>


  export type SessionSelectScalar = {
    id?: boolean
    userId?: boolean
    refreshToken?: boolean
    userAgent?: boolean
    ip?: boolean
    createdAt?: boolean
    revokedAt?: boolean
  }

  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      refreshToken: string
      userAgent: string | null
      ip: string | null
      createdAt: Date
      revokedAt: Date | null
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Sessions that matches the filter.
     * @param {SessionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const session = await prisma.session.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: SessionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Session.
     * @param {SessionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const session = await prisma.session.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SessionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */ 
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly refreshToken: FieldRef<"Session", 'String'>
    readonly userAgent: FieldRef<"Session", 'String'>
    readonly ip: FieldRef<"Session", 'String'>
    readonly createdAt: FieldRef<"Session", 'DateTime'>
    readonly revokedAt: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
  }

  /**
   * Session findRaw
   */
  export type SessionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session aggregateRaw
   */
  export type SessionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    body: string | null
    status: $Enums.PageStatus | null
    createdById: string | null
    updatedById: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    body: string | null
    status: $Enums.PageStatus | null
    createdById: string | null
    updatedById: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    body: number
    status: number
    meta: number
    createdById: number
    updatedById: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PageMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    body?: true
    status?: true
    createdById?: true
    updatedById?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    body?: true
    status?: true
    createdById?: true
    updatedById?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    body?: true
    status?: true
    meta?: true
    createdById?: true
    updatedById?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
        [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }




  export type PageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
    orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
    by: PageScalarFieldEnum[] | PageScalarFieldEnum
    having?: PageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageCountAggregateInputType | true
    _min?: PageMinAggregateInputType
    _max?: PageMaxAggregateInputType
  }

  export type PageGroupByOutputType = {
    id: string
    title: string
    slug: string
    body: string
    status: $Enums.PageStatus
    meta: JsonValue | null
    createdById: string
    updatedById: string | null
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PageCountAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageGroupByOutputType[P]>
            : GetScalarType<T[P], PageGroupByOutputType[P]>
        }
      >
    >


  export type PageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    body?: boolean
    status?: boolean
    meta?: boolean
    createdById?: boolean
    updatedById?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Page$updatedByArgs<ExtArgs>
  }, ExtArgs["result"]["page"]>


  export type PageSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    body?: boolean
    status?: boolean
    meta?: boolean
    createdById?: boolean
    updatedById?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    updatedBy?: boolean | Page$updatedByArgs<ExtArgs>
  }

  export type $PagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Page"
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>
      updatedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      body: string
      status: $Enums.PageStatus
      meta: Prisma.JsonValue | null
      createdById: string
      updatedById: string | null
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["page"]>
    composites: {}
  }

  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<Prisma.$PagePayload, S>

  type PageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PageCountAggregateInputType | true
    }

  export interface PageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Page'], meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageFindUniqueArgs>(args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Page that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs>(args: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageFindFirstArgs>(args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs>(args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageFindManyArgs>(args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     * 
     */
    create<T extends PageCreateArgs>(args: SelectSubset<T, PageCreateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pages.
     * @param {PageCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageCreateManyArgs>(args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     * 
     */
    delete<T extends PageDeleteArgs>(args: SelectSubset<T, PageDeleteArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageUpdateArgs>(args: SelectSubset<T, PageUpdateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageDeleteManyArgs>(args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageUpdateManyArgs>(args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
     */
    upsert<T extends PageUpsertArgs>(args: SelectSubset<T, PageUpsertArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Pages that matches the filter.
     * @param {PageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const page = await prisma.page.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: PageFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Page.
     * @param {PageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const page = await prisma.page.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PageAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAggregateArgs>(args: Subset<T, PageAggregateArgs>): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Page model
   */
  readonly fields: PageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    updatedBy<T extends Page$updatedByArgs<ExtArgs> = {}>(args?: Subset<T, Page$updatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Page model
   */ 
  interface PageFieldRefs {
    readonly id: FieldRef<"Page", 'String'>
    readonly title: FieldRef<"Page", 'String'>
    readonly slug: FieldRef<"Page", 'String'>
    readonly body: FieldRef<"Page", 'String'>
    readonly status: FieldRef<"Page", 'PageStatus'>
    readonly meta: FieldRef<"Page", 'Json'>
    readonly createdById: FieldRef<"Page", 'String'>
    readonly updatedById: FieldRef<"Page", 'String'>
    readonly publishedAt: FieldRef<"Page", 'DateTime'>
    readonly createdAt: FieldRef<"Page", 'DateTime'>
    readonly updatedAt: FieldRef<"Page", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter, which Pages to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }

  /**
   * Page createMany
   */
  export type PageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
  }

  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
  }

  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }

  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
  }

  /**
   * Page findRaw
   */
  export type PageFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Page aggregateRaw
   */
  export type PageAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Page.updatedBy
   */
  export type Page$updatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PageInclude<ExtArgs> | null
  }


  /**
   * Model UploadAsset
   */

  export type AggregateUploadAsset = {
    _count: UploadAssetCountAggregateOutputType | null
    _avg: UploadAssetAvgAggregateOutputType | null
    _sum: UploadAssetSumAggregateOutputType | null
    _min: UploadAssetMinAggregateOutputType | null
    _max: UploadAssetMaxAggregateOutputType | null
  }

  export type UploadAssetAvgAggregateOutputType = {
    size: number | null
  }

  export type UploadAssetSumAggregateOutputType = {
    size: number | null
  }

  export type UploadAssetMinAggregateOutputType = {
    id: string | null
    objectKey: string | null
    contentType: string | null
    size: number | null
    publicUrl: string | null
    context: string | null
    uploaderId: string | null
    createdAt: Date | null
  }

  export type UploadAssetMaxAggregateOutputType = {
    id: string | null
    objectKey: string | null
    contentType: string | null
    size: number | null
    publicUrl: string | null
    context: string | null
    uploaderId: string | null
    createdAt: Date | null
  }

  export type UploadAssetCountAggregateOutputType = {
    id: number
    objectKey: number
    contentType: number
    size: number
    publicUrl: number
    context: number
    uploaderId: number
    createdAt: number
    _all: number
  }


  export type UploadAssetAvgAggregateInputType = {
    size?: true
  }

  export type UploadAssetSumAggregateInputType = {
    size?: true
  }

  export type UploadAssetMinAggregateInputType = {
    id?: true
    objectKey?: true
    contentType?: true
    size?: true
    publicUrl?: true
    context?: true
    uploaderId?: true
    createdAt?: true
  }

  export type UploadAssetMaxAggregateInputType = {
    id?: true
    objectKey?: true
    contentType?: true
    size?: true
    publicUrl?: true
    context?: true
    uploaderId?: true
    createdAt?: true
  }

  export type UploadAssetCountAggregateInputType = {
    id?: true
    objectKey?: true
    contentType?: true
    size?: true
    publicUrl?: true
    context?: true
    uploaderId?: true
    createdAt?: true
    _all?: true
  }

  export type UploadAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadAsset to aggregate.
     */
    where?: UploadAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadAssets to fetch.
     */
    orderBy?: UploadAssetOrderByWithRelationInput | UploadAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UploadAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UploadAssets
    **/
    _count?: true | UploadAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UploadAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UploadAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UploadAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UploadAssetMaxAggregateInputType
  }

  export type GetUploadAssetAggregateType<T extends UploadAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateUploadAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUploadAsset[P]>
      : GetScalarType<T[P], AggregateUploadAsset[P]>
  }




  export type UploadAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UploadAssetWhereInput
    orderBy?: UploadAssetOrderByWithAggregationInput | UploadAssetOrderByWithAggregationInput[]
    by: UploadAssetScalarFieldEnum[] | UploadAssetScalarFieldEnum
    having?: UploadAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UploadAssetCountAggregateInputType | true
    _avg?: UploadAssetAvgAggregateInputType
    _sum?: UploadAssetSumAggregateInputType
    _min?: UploadAssetMinAggregateInputType
    _max?: UploadAssetMaxAggregateInputType
  }

  export type UploadAssetGroupByOutputType = {
    id: string
    objectKey: string
    contentType: string
    size: number
    publicUrl: string | null
    context: string | null
    uploaderId: string | null
    createdAt: Date
    _count: UploadAssetCountAggregateOutputType | null
    _avg: UploadAssetAvgAggregateOutputType | null
    _sum: UploadAssetSumAggregateOutputType | null
    _min: UploadAssetMinAggregateOutputType | null
    _max: UploadAssetMaxAggregateOutputType | null
  }

  type GetUploadAssetGroupByPayload<T extends UploadAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UploadAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UploadAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UploadAssetGroupByOutputType[P]>
            : GetScalarType<T[P], UploadAssetGroupByOutputType[P]>
        }
      >
    >


  export type UploadAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    objectKey?: boolean
    contentType?: boolean
    size?: boolean
    publicUrl?: boolean
    context?: boolean
    uploaderId?: boolean
    createdAt?: boolean
    uploader?: boolean | UploadAsset$uploaderArgs<ExtArgs>
  }, ExtArgs["result"]["uploadAsset"]>


  export type UploadAssetSelectScalar = {
    id?: boolean
    objectKey?: boolean
    contentType?: boolean
    size?: boolean
    publicUrl?: boolean
    context?: boolean
    uploaderId?: boolean
    createdAt?: boolean
  }

  export type UploadAssetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    uploader?: boolean | UploadAsset$uploaderArgs<ExtArgs>
  }

  export type $UploadAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UploadAsset"
    objects: {
      uploader: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      objectKey: string
      contentType: string
      size: number
      publicUrl: string | null
      context: string | null
      uploaderId: string | null
      createdAt: Date
    }, ExtArgs["result"]["uploadAsset"]>
    composites: {}
  }

  type UploadAssetGetPayload<S extends boolean | null | undefined | UploadAssetDefaultArgs> = $Result.GetResult<Prisma.$UploadAssetPayload, S>

  type UploadAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UploadAssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UploadAssetCountAggregateInputType | true
    }

  export interface UploadAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UploadAsset'], meta: { name: 'UploadAsset' } }
    /**
     * Find zero or one UploadAsset that matches the filter.
     * @param {UploadAssetFindUniqueArgs} args - Arguments to find a UploadAsset
     * @example
     * // Get one UploadAsset
     * const uploadAsset = await prisma.uploadAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UploadAssetFindUniqueArgs>(args: SelectSubset<T, UploadAssetFindUniqueArgs<ExtArgs>>): Prisma__UploadAssetClient<$Result.GetResult<Prisma.$UploadAssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UploadAsset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UploadAssetFindUniqueOrThrowArgs} args - Arguments to find a UploadAsset
     * @example
     * // Get one UploadAsset
     * const uploadAsset = await prisma.uploadAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UploadAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, UploadAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UploadAssetClient<$Result.GetResult<Prisma.$UploadAssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UploadAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadAssetFindFirstArgs} args - Arguments to find a UploadAsset
     * @example
     * // Get one UploadAsset
     * const uploadAsset = await prisma.uploadAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UploadAssetFindFirstArgs>(args?: SelectSubset<T, UploadAssetFindFirstArgs<ExtArgs>>): Prisma__UploadAssetClient<$Result.GetResult<Prisma.$UploadAssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UploadAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadAssetFindFirstOrThrowArgs} args - Arguments to find a UploadAsset
     * @example
     * // Get one UploadAsset
     * const uploadAsset = await prisma.uploadAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UploadAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, UploadAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__UploadAssetClient<$Result.GetResult<Prisma.$UploadAssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UploadAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UploadAssets
     * const uploadAssets = await prisma.uploadAsset.findMany()
     * 
     * // Get first 10 UploadAssets
     * const uploadAssets = await prisma.uploadAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const uploadAssetWithIdOnly = await prisma.uploadAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UploadAssetFindManyArgs>(args?: SelectSubset<T, UploadAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UploadAssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UploadAsset.
     * @param {UploadAssetCreateArgs} args - Arguments to create a UploadAsset.
     * @example
     * // Create one UploadAsset
     * const UploadAsset = await prisma.uploadAsset.create({
     *   data: {
     *     // ... data to create a UploadAsset
     *   }
     * })
     * 
     */
    create<T extends UploadAssetCreateArgs>(args: SelectSubset<T, UploadAssetCreateArgs<ExtArgs>>): Prisma__UploadAssetClient<$Result.GetResult<Prisma.$UploadAssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UploadAssets.
     * @param {UploadAssetCreateManyArgs} args - Arguments to create many UploadAssets.
     * @example
     * // Create many UploadAssets
     * const uploadAsset = await prisma.uploadAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UploadAssetCreateManyArgs>(args?: SelectSubset<T, UploadAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UploadAsset.
     * @param {UploadAssetDeleteArgs} args - Arguments to delete one UploadAsset.
     * @example
     * // Delete one UploadAsset
     * const UploadAsset = await prisma.uploadAsset.delete({
     *   where: {
     *     // ... filter to delete one UploadAsset
     *   }
     * })
     * 
     */
    delete<T extends UploadAssetDeleteArgs>(args: SelectSubset<T, UploadAssetDeleteArgs<ExtArgs>>): Prisma__UploadAssetClient<$Result.GetResult<Prisma.$UploadAssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UploadAsset.
     * @param {UploadAssetUpdateArgs} args - Arguments to update one UploadAsset.
     * @example
     * // Update one UploadAsset
     * const uploadAsset = await prisma.uploadAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UploadAssetUpdateArgs>(args: SelectSubset<T, UploadAssetUpdateArgs<ExtArgs>>): Prisma__UploadAssetClient<$Result.GetResult<Prisma.$UploadAssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UploadAssets.
     * @param {UploadAssetDeleteManyArgs} args - Arguments to filter UploadAssets to delete.
     * @example
     * // Delete a few UploadAssets
     * const { count } = await prisma.uploadAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UploadAssetDeleteManyArgs>(args?: SelectSubset<T, UploadAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UploadAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UploadAssets
     * const uploadAsset = await prisma.uploadAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UploadAssetUpdateManyArgs>(args: SelectSubset<T, UploadAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UploadAsset.
     * @param {UploadAssetUpsertArgs} args - Arguments to update or create a UploadAsset.
     * @example
     * // Update or create a UploadAsset
     * const uploadAsset = await prisma.uploadAsset.upsert({
     *   create: {
     *     // ... data to create a UploadAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UploadAsset we want to update
     *   }
     * })
     */
    upsert<T extends UploadAssetUpsertArgs>(args: SelectSubset<T, UploadAssetUpsertArgs<ExtArgs>>): Prisma__UploadAssetClient<$Result.GetResult<Prisma.$UploadAssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more UploadAssets that matches the filter.
     * @param {UploadAssetFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const uploadAsset = await prisma.uploadAsset.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UploadAssetFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a UploadAsset.
     * @param {UploadAssetAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const uploadAsset = await prisma.uploadAsset.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UploadAssetAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of UploadAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadAssetCountArgs} args - Arguments to filter UploadAssets to count.
     * @example
     * // Count the number of UploadAssets
     * const count = await prisma.uploadAsset.count({
     *   where: {
     *     // ... the filter for the UploadAssets we want to count
     *   }
     * })
    **/
    count<T extends UploadAssetCountArgs>(
      args?: Subset<T, UploadAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UploadAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UploadAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UploadAssetAggregateArgs>(args: Subset<T, UploadAssetAggregateArgs>): Prisma.PrismaPromise<GetUploadAssetAggregateType<T>>

    /**
     * Group by UploadAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UploadAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UploadAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UploadAssetGroupByArgs['orderBy'] }
        : { orderBy?: UploadAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UploadAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUploadAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UploadAsset model
   */
  readonly fields: UploadAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UploadAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UploadAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    uploader<T extends UploadAsset$uploaderArgs<ExtArgs> = {}>(args?: Subset<T, UploadAsset$uploaderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UploadAsset model
   */ 
  interface UploadAssetFieldRefs {
    readonly id: FieldRef<"UploadAsset", 'String'>
    readonly objectKey: FieldRef<"UploadAsset", 'String'>
    readonly contentType: FieldRef<"UploadAsset", 'String'>
    readonly size: FieldRef<"UploadAsset", 'Int'>
    readonly publicUrl: FieldRef<"UploadAsset", 'String'>
    readonly context: FieldRef<"UploadAsset", 'String'>
    readonly uploaderId: FieldRef<"UploadAsset", 'String'>
    readonly createdAt: FieldRef<"UploadAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UploadAsset findUnique
   */
  export type UploadAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadAsset
     */
    select?: UploadAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadAssetInclude<ExtArgs> | null
    /**
     * Filter, which UploadAsset to fetch.
     */
    where: UploadAssetWhereUniqueInput
  }

  /**
   * UploadAsset findUniqueOrThrow
   */
  export type UploadAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadAsset
     */
    select?: UploadAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadAssetInclude<ExtArgs> | null
    /**
     * Filter, which UploadAsset to fetch.
     */
    where: UploadAssetWhereUniqueInput
  }

  /**
   * UploadAsset findFirst
   */
  export type UploadAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadAsset
     */
    select?: UploadAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadAssetInclude<ExtArgs> | null
    /**
     * Filter, which UploadAsset to fetch.
     */
    where?: UploadAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadAssets to fetch.
     */
    orderBy?: UploadAssetOrderByWithRelationInput | UploadAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadAssets.
     */
    cursor?: UploadAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadAssets.
     */
    distinct?: UploadAssetScalarFieldEnum | UploadAssetScalarFieldEnum[]
  }

  /**
   * UploadAsset findFirstOrThrow
   */
  export type UploadAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadAsset
     */
    select?: UploadAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadAssetInclude<ExtArgs> | null
    /**
     * Filter, which UploadAsset to fetch.
     */
    where?: UploadAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadAssets to fetch.
     */
    orderBy?: UploadAssetOrderByWithRelationInput | UploadAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UploadAssets.
     */
    cursor?: UploadAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UploadAssets.
     */
    distinct?: UploadAssetScalarFieldEnum | UploadAssetScalarFieldEnum[]
  }

  /**
   * UploadAsset findMany
   */
  export type UploadAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadAsset
     */
    select?: UploadAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadAssetInclude<ExtArgs> | null
    /**
     * Filter, which UploadAssets to fetch.
     */
    where?: UploadAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UploadAssets to fetch.
     */
    orderBy?: UploadAssetOrderByWithRelationInput | UploadAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UploadAssets.
     */
    cursor?: UploadAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UploadAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UploadAssets.
     */
    skip?: number
    distinct?: UploadAssetScalarFieldEnum | UploadAssetScalarFieldEnum[]
  }

  /**
   * UploadAsset create
   */
  export type UploadAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadAsset
     */
    select?: UploadAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadAssetInclude<ExtArgs> | null
    /**
     * The data needed to create a UploadAsset.
     */
    data: XOR<UploadAssetCreateInput, UploadAssetUncheckedCreateInput>
  }

  /**
   * UploadAsset createMany
   */
  export type UploadAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UploadAssets.
     */
    data: UploadAssetCreateManyInput | UploadAssetCreateManyInput[]
  }

  /**
   * UploadAsset update
   */
  export type UploadAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadAsset
     */
    select?: UploadAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadAssetInclude<ExtArgs> | null
    /**
     * The data needed to update a UploadAsset.
     */
    data: XOR<UploadAssetUpdateInput, UploadAssetUncheckedUpdateInput>
    /**
     * Choose, which UploadAsset to update.
     */
    where: UploadAssetWhereUniqueInput
  }

  /**
   * UploadAsset updateMany
   */
  export type UploadAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UploadAssets.
     */
    data: XOR<UploadAssetUpdateManyMutationInput, UploadAssetUncheckedUpdateManyInput>
    /**
     * Filter which UploadAssets to update
     */
    where?: UploadAssetWhereInput
  }

  /**
   * UploadAsset upsert
   */
  export type UploadAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadAsset
     */
    select?: UploadAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadAssetInclude<ExtArgs> | null
    /**
     * The filter to search for the UploadAsset to update in case it exists.
     */
    where: UploadAssetWhereUniqueInput
    /**
     * In case the UploadAsset found by the `where` argument doesn't exist, create a new UploadAsset with this data.
     */
    create: XOR<UploadAssetCreateInput, UploadAssetUncheckedCreateInput>
    /**
     * In case the UploadAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UploadAssetUpdateInput, UploadAssetUncheckedUpdateInput>
  }

  /**
   * UploadAsset delete
   */
  export type UploadAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadAsset
     */
    select?: UploadAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadAssetInclude<ExtArgs> | null
    /**
     * Filter which UploadAsset to delete.
     */
    where: UploadAssetWhereUniqueInput
  }

  /**
   * UploadAsset deleteMany
   */
  export type UploadAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UploadAssets to delete
     */
    where?: UploadAssetWhereInput
  }

  /**
   * UploadAsset findRaw
   */
  export type UploadAssetFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UploadAsset aggregateRaw
   */
  export type UploadAssetAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * UploadAsset.uploader
   */
  export type UploadAsset$uploaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * UploadAsset without action
   */
  export type UploadAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UploadAsset
     */
    select?: UploadAssetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UploadAssetInclude<ExtArgs> | null
  }


  /**
   * Model Installation
   */

  export type AggregateInstallation = {
    _count: InstallationCountAggregateOutputType | null
    _min: InstallationMinAggregateOutputType | null
    _max: InstallationMaxAggregateOutputType | null
  }

  export type InstallationMinAggregateOutputType = {
    id: string | null
    dealerId: string | null
    siteName: string | null
    scheduledAt: Date | null
    status: $Enums.InstallStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstallationMaxAggregateOutputType = {
    id: string | null
    dealerId: string | null
    siteName: string | null
    scheduledAt: Date | null
    status: $Enums.InstallStatus | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstallationCountAggregateOutputType = {
    id: number
    dealerId: number
    siteName: number
    address: number
    customerInfo: number
    scheduledAt: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstallationMinAggregateInputType = {
    id?: true
    dealerId?: true
    siteName?: true
    scheduledAt?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstallationMaxAggregateInputType = {
    id?: true
    dealerId?: true
    siteName?: true
    scheduledAt?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstallationCountAggregateInputType = {
    id?: true
    dealerId?: true
    siteName?: true
    address?: true
    customerInfo?: true
    scheduledAt?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstallationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Installation to aggregate.
     */
    where?: InstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installations to fetch.
     */
    orderBy?: InstallationOrderByWithRelationInput | InstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Installations
    **/
    _count?: true | InstallationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstallationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstallationMaxAggregateInputType
  }

  export type GetInstallationAggregateType<T extends InstallationAggregateArgs> = {
        [P in keyof T & keyof AggregateInstallation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstallation[P]>
      : GetScalarType<T[P], AggregateInstallation[P]>
  }




  export type InstallationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstallationWhereInput
    orderBy?: InstallationOrderByWithAggregationInput | InstallationOrderByWithAggregationInput[]
    by: InstallationScalarFieldEnum[] | InstallationScalarFieldEnum
    having?: InstallationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstallationCountAggregateInputType | true
    _min?: InstallationMinAggregateInputType
    _max?: InstallationMaxAggregateInputType
  }

  export type InstallationGroupByOutputType = {
    id: string
    dealerId: string | null
    siteName: string
    address: JsonValue | null
    customerInfo: JsonValue | null
    scheduledAt: Date | null
    status: $Enums.InstallStatus
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InstallationCountAggregateOutputType | null
    _min: InstallationMinAggregateOutputType | null
    _max: InstallationMaxAggregateOutputType | null
  }

  type GetInstallationGroupByPayload<T extends InstallationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstallationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstallationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstallationGroupByOutputType[P]>
            : GetScalarType<T[P], InstallationGroupByOutputType[P]>
        }
      >
    >


  export type InstallationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dealerId?: boolean
    siteName?: boolean
    address?: boolean
    customerInfo?: boolean
    scheduledAt?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reports?: boolean | Installation$reportsArgs<ExtArgs>
    _count?: boolean | InstallationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["installation"]>


  export type InstallationSelectScalar = {
    id?: boolean
    dealerId?: boolean
    siteName?: boolean
    address?: boolean
    customerInfo?: boolean
    scheduledAt?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstallationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | Installation$reportsArgs<ExtArgs>
    _count?: boolean | InstallationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $InstallationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Installation"
    objects: {
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dealerId: string | null
      siteName: string
      address: Prisma.JsonValue | null
      customerInfo: Prisma.JsonValue | null
      scheduledAt: Date | null
      status: $Enums.InstallStatus
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["installation"]>
    composites: {}
  }

  type InstallationGetPayload<S extends boolean | null | undefined | InstallationDefaultArgs> = $Result.GetResult<Prisma.$InstallationPayload, S>

  type InstallationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InstallationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InstallationCountAggregateInputType | true
    }

  export interface InstallationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Installation'], meta: { name: 'Installation' } }
    /**
     * Find zero or one Installation that matches the filter.
     * @param {InstallationFindUniqueArgs} args - Arguments to find a Installation
     * @example
     * // Get one Installation
     * const installation = await prisma.installation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstallationFindUniqueArgs>(args: SelectSubset<T, InstallationFindUniqueArgs<ExtArgs>>): Prisma__InstallationClient<$Result.GetResult<Prisma.$InstallationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Installation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InstallationFindUniqueOrThrowArgs} args - Arguments to find a Installation
     * @example
     * // Get one Installation
     * const installation = await prisma.installation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstallationFindUniqueOrThrowArgs>(args: SelectSubset<T, InstallationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstallationClient<$Result.GetResult<Prisma.$InstallationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Installation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallationFindFirstArgs} args - Arguments to find a Installation
     * @example
     * // Get one Installation
     * const installation = await prisma.installation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstallationFindFirstArgs>(args?: SelectSubset<T, InstallationFindFirstArgs<ExtArgs>>): Prisma__InstallationClient<$Result.GetResult<Prisma.$InstallationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Installation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallationFindFirstOrThrowArgs} args - Arguments to find a Installation
     * @example
     * // Get one Installation
     * const installation = await prisma.installation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstallationFindFirstOrThrowArgs>(args?: SelectSubset<T, InstallationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstallationClient<$Result.GetResult<Prisma.$InstallationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Installations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Installations
     * const installations = await prisma.installation.findMany()
     * 
     * // Get first 10 Installations
     * const installations = await prisma.installation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const installationWithIdOnly = await prisma.installation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstallationFindManyArgs>(args?: SelectSubset<T, InstallationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstallationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Installation.
     * @param {InstallationCreateArgs} args - Arguments to create a Installation.
     * @example
     * // Create one Installation
     * const Installation = await prisma.installation.create({
     *   data: {
     *     // ... data to create a Installation
     *   }
     * })
     * 
     */
    create<T extends InstallationCreateArgs>(args: SelectSubset<T, InstallationCreateArgs<ExtArgs>>): Prisma__InstallationClient<$Result.GetResult<Prisma.$InstallationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Installations.
     * @param {InstallationCreateManyArgs} args - Arguments to create many Installations.
     * @example
     * // Create many Installations
     * const installation = await prisma.installation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstallationCreateManyArgs>(args?: SelectSubset<T, InstallationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Installation.
     * @param {InstallationDeleteArgs} args - Arguments to delete one Installation.
     * @example
     * // Delete one Installation
     * const Installation = await prisma.installation.delete({
     *   where: {
     *     // ... filter to delete one Installation
     *   }
     * })
     * 
     */
    delete<T extends InstallationDeleteArgs>(args: SelectSubset<T, InstallationDeleteArgs<ExtArgs>>): Prisma__InstallationClient<$Result.GetResult<Prisma.$InstallationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Installation.
     * @param {InstallationUpdateArgs} args - Arguments to update one Installation.
     * @example
     * // Update one Installation
     * const installation = await prisma.installation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstallationUpdateArgs>(args: SelectSubset<T, InstallationUpdateArgs<ExtArgs>>): Prisma__InstallationClient<$Result.GetResult<Prisma.$InstallationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Installations.
     * @param {InstallationDeleteManyArgs} args - Arguments to filter Installations to delete.
     * @example
     * // Delete a few Installations
     * const { count } = await prisma.installation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstallationDeleteManyArgs>(args?: SelectSubset<T, InstallationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Installations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Installations
     * const installation = await prisma.installation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstallationUpdateManyArgs>(args: SelectSubset<T, InstallationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Installation.
     * @param {InstallationUpsertArgs} args - Arguments to update or create a Installation.
     * @example
     * // Update or create a Installation
     * const installation = await prisma.installation.upsert({
     *   create: {
     *     // ... data to create a Installation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Installation we want to update
     *   }
     * })
     */
    upsert<T extends InstallationUpsertArgs>(args: SelectSubset<T, InstallationUpsertArgs<ExtArgs>>): Prisma__InstallationClient<$Result.GetResult<Prisma.$InstallationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Installations that matches the filter.
     * @param {InstallationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const installation = await prisma.installation.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: InstallationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Installation.
     * @param {InstallationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const installation = await prisma.installation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: InstallationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Installations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallationCountArgs} args - Arguments to filter Installations to count.
     * @example
     * // Count the number of Installations
     * const count = await prisma.installation.count({
     *   where: {
     *     // ... the filter for the Installations we want to count
     *   }
     * })
    **/
    count<T extends InstallationCountArgs>(
      args?: Subset<T, InstallationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstallationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Installation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstallationAggregateArgs>(args: Subset<T, InstallationAggregateArgs>): Prisma.PrismaPromise<GetInstallationAggregateType<T>>

    /**
     * Group by Installation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstallationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstallationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstallationGroupByArgs['orderBy'] }
        : { orderBy?: InstallationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstallationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstallationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Installation model
   */
  readonly fields: InstallationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Installation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstallationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reports<T extends Installation$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Installation$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Installation model
   */ 
  interface InstallationFieldRefs {
    readonly id: FieldRef<"Installation", 'String'>
    readonly dealerId: FieldRef<"Installation", 'String'>
    readonly siteName: FieldRef<"Installation", 'String'>
    readonly address: FieldRef<"Installation", 'Json'>
    readonly customerInfo: FieldRef<"Installation", 'Json'>
    readonly scheduledAt: FieldRef<"Installation", 'DateTime'>
    readonly status: FieldRef<"Installation", 'InstallStatus'>
    readonly notes: FieldRef<"Installation", 'String'>
    readonly createdAt: FieldRef<"Installation", 'DateTime'>
    readonly updatedAt: FieldRef<"Installation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Installation findUnique
   */
  export type InstallationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installation
     */
    select?: InstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallationInclude<ExtArgs> | null
    /**
     * Filter, which Installation to fetch.
     */
    where: InstallationWhereUniqueInput
  }

  /**
   * Installation findUniqueOrThrow
   */
  export type InstallationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installation
     */
    select?: InstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallationInclude<ExtArgs> | null
    /**
     * Filter, which Installation to fetch.
     */
    where: InstallationWhereUniqueInput
  }

  /**
   * Installation findFirst
   */
  export type InstallationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installation
     */
    select?: InstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallationInclude<ExtArgs> | null
    /**
     * Filter, which Installation to fetch.
     */
    where?: InstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installations to fetch.
     */
    orderBy?: InstallationOrderByWithRelationInput | InstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Installations.
     */
    cursor?: InstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Installations.
     */
    distinct?: InstallationScalarFieldEnum | InstallationScalarFieldEnum[]
  }

  /**
   * Installation findFirstOrThrow
   */
  export type InstallationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installation
     */
    select?: InstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallationInclude<ExtArgs> | null
    /**
     * Filter, which Installation to fetch.
     */
    where?: InstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installations to fetch.
     */
    orderBy?: InstallationOrderByWithRelationInput | InstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Installations.
     */
    cursor?: InstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Installations.
     */
    distinct?: InstallationScalarFieldEnum | InstallationScalarFieldEnum[]
  }

  /**
   * Installation findMany
   */
  export type InstallationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installation
     */
    select?: InstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallationInclude<ExtArgs> | null
    /**
     * Filter, which Installations to fetch.
     */
    where?: InstallationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Installations to fetch.
     */
    orderBy?: InstallationOrderByWithRelationInput | InstallationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Installations.
     */
    cursor?: InstallationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Installations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Installations.
     */
    skip?: number
    distinct?: InstallationScalarFieldEnum | InstallationScalarFieldEnum[]
  }

  /**
   * Installation create
   */
  export type InstallationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installation
     */
    select?: InstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallationInclude<ExtArgs> | null
    /**
     * The data needed to create a Installation.
     */
    data: XOR<InstallationCreateInput, InstallationUncheckedCreateInput>
  }

  /**
   * Installation createMany
   */
  export type InstallationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Installations.
     */
    data: InstallationCreateManyInput | InstallationCreateManyInput[]
  }

  /**
   * Installation update
   */
  export type InstallationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installation
     */
    select?: InstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallationInclude<ExtArgs> | null
    /**
     * The data needed to update a Installation.
     */
    data: XOR<InstallationUpdateInput, InstallationUncheckedUpdateInput>
    /**
     * Choose, which Installation to update.
     */
    where: InstallationWhereUniqueInput
  }

  /**
   * Installation updateMany
   */
  export type InstallationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Installations.
     */
    data: XOR<InstallationUpdateManyMutationInput, InstallationUncheckedUpdateManyInput>
    /**
     * Filter which Installations to update
     */
    where?: InstallationWhereInput
  }

  /**
   * Installation upsert
   */
  export type InstallationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installation
     */
    select?: InstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallationInclude<ExtArgs> | null
    /**
     * The filter to search for the Installation to update in case it exists.
     */
    where: InstallationWhereUniqueInput
    /**
     * In case the Installation found by the `where` argument doesn't exist, create a new Installation with this data.
     */
    create: XOR<InstallationCreateInput, InstallationUncheckedCreateInput>
    /**
     * In case the Installation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstallationUpdateInput, InstallationUncheckedUpdateInput>
  }

  /**
   * Installation delete
   */
  export type InstallationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installation
     */
    select?: InstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallationInclude<ExtArgs> | null
    /**
     * Filter which Installation to delete.
     */
    where: InstallationWhereUniqueInput
  }

  /**
   * Installation deleteMany
   */
  export type InstallationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Installations to delete
     */
    where?: InstallationWhereInput
  }

  /**
   * Installation findRaw
   */
  export type InstallationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Installation aggregateRaw
   */
  export type InstallationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Installation.reports
   */
  export type Installation$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Installation without action
   */
  export type InstallationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Installation
     */
    select?: InstallationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstallationInclude<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    installationId: string | null
    reportType: string | null
    notes: string | null
    uploadObjectKey: string | null
    createdAt: Date | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    installationId: string | null
    reportType: string | null
    notes: string | null
    uploadObjectKey: string | null
    createdAt: Date | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    installationId: number
    reportType: number
    notes: number
    uploadObjectKey: number
    createdAt: number
    _all: number
  }


  export type ReportMinAggregateInputType = {
    id?: true
    installationId?: true
    reportType?: true
    notes?: true
    uploadObjectKey?: true
    createdAt?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    installationId?: true
    reportType?: true
    notes?: true
    uploadObjectKey?: true
    createdAt?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    installationId?: true
    reportType?: true
    notes?: true
    uploadObjectKey?: true
    createdAt?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: string
    installationId: string
    reportType: string
    notes: string | null
    uploadObjectKey: string
    createdAt: Date
    _count: ReportCountAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    installationId?: boolean
    reportType?: boolean
    notes?: boolean
    uploadObjectKey?: boolean
    createdAt?: boolean
    installation?: boolean | InstallationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>


  export type ReportSelectScalar = {
    id?: boolean
    installationId?: boolean
    reportType?: boolean
    notes?: boolean
    uploadObjectKey?: boolean
    createdAt?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installation?: boolean | InstallationDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      installation: Prisma.$InstallationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      installationId: string
      reportType: string
      notes: string | null
      uploadObjectKey: string
      createdAt: Date
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * @param {ReportFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const report = await prisma.report.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ReportFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Report.
     * @param {ReportAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const report = await prisma.report.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ReportAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    installation<T extends InstallationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstallationDefaultArgs<ExtArgs>>): Prisma__InstallationClient<$Result.GetResult<Prisma.$InstallationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'String'>
    readonly installationId: FieldRef<"Report", 'String'>
    readonly reportType: FieldRef<"Report", 'String'>
    readonly notes: FieldRef<"Report", 'String'>
    readonly uploadObjectKey: FieldRef<"Report", 'String'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report findRaw
   */
  export type ReportFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Report aggregateRaw
   */
  export type ReportAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model AuditEvent
   */

  export type AggregateAuditEvent = {
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  export type AuditEventMinAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    target: string | null
    createdAt: Date | null
  }

  export type AuditEventMaxAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    target: string | null
    createdAt: Date | null
  }

  export type AuditEventCountAggregateOutputType = {
    id: number
    actorId: number
    action: number
    target: number
    meta: number
    createdAt: number
    _all: number
  }


  export type AuditEventMinAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    target?: true
    createdAt?: true
  }

  export type AuditEventMaxAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    target?: true
    createdAt?: true
  }

  export type AuditEventCountAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    target?: true
    meta?: true
    createdAt?: true
    _all?: true
  }

  export type AuditEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvent to aggregate.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditEvents
    **/
    _count?: true | AuditEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditEventMaxAggregateInputType
  }

  export type GetAuditEventAggregateType<T extends AuditEventAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditEvent[P]>
      : GetScalarType<T[P], AggregateAuditEvent[P]>
  }




  export type AuditEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditEventWhereInput
    orderBy?: AuditEventOrderByWithAggregationInput | AuditEventOrderByWithAggregationInput[]
    by: AuditEventScalarFieldEnum[] | AuditEventScalarFieldEnum
    having?: AuditEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditEventCountAggregateInputType | true
    _min?: AuditEventMinAggregateInputType
    _max?: AuditEventMaxAggregateInputType
  }

  export type AuditEventGroupByOutputType = {
    id: string
    actorId: string | null
    action: string
    target: string | null
    meta: JsonValue | null
    createdAt: Date
    _count: AuditEventCountAggregateOutputType | null
    _min: AuditEventMinAggregateOutputType | null
    _max: AuditEventMaxAggregateOutputType | null
  }

  type GetAuditEventGroupByPayload<T extends AuditEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
            : GetScalarType<T[P], AuditEventGroupByOutputType[P]>
        }
      >
    >


  export type AuditEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    target?: boolean
    meta?: boolean
    createdAt?: boolean
    actor?: boolean | AuditEvent$actorArgs<ExtArgs>
  }, ExtArgs["result"]["auditEvent"]>


  export type AuditEventSelectScalar = {
    id?: boolean
    actorId?: boolean
    action?: boolean
    target?: boolean
    meta?: boolean
    createdAt?: boolean
  }

  export type AuditEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | AuditEvent$actorArgs<ExtArgs>
  }

  export type $AuditEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditEvent"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorId: string | null
      action: string
      target: string | null
      meta: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditEvent"]>
    composites: {}
  }

  type AuditEventGetPayload<S extends boolean | null | undefined | AuditEventDefaultArgs> = $Result.GetResult<Prisma.$AuditEventPayload, S>

  type AuditEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditEventCountAggregateInputType | true
    }

  export interface AuditEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditEvent'], meta: { name: 'AuditEvent' } }
    /**
     * Find zero or one AuditEvent that matches the filter.
     * @param {AuditEventFindUniqueArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditEventFindUniqueArgs>(args: SelectSubset<T, AuditEventFindUniqueArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditEventFindUniqueOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditEventFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditEventFindFirstArgs>(args?: SelectSubset<T, AuditEventFindFirstArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindFirstOrThrowArgs} args - Arguments to find a AuditEvent
     * @example
     * // Get one AuditEvent
     * const auditEvent = await prisma.auditEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditEventFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany()
     * 
     * // Get first 10 AuditEvents
     * const auditEvents = await prisma.auditEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditEventWithIdOnly = await prisma.auditEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditEventFindManyArgs>(args?: SelectSubset<T, AuditEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditEvent.
     * @param {AuditEventCreateArgs} args - Arguments to create a AuditEvent.
     * @example
     * // Create one AuditEvent
     * const AuditEvent = await prisma.auditEvent.create({
     *   data: {
     *     // ... data to create a AuditEvent
     *   }
     * })
     * 
     */
    create<T extends AuditEventCreateArgs>(args: SelectSubset<T, AuditEventCreateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditEvents.
     * @param {AuditEventCreateManyArgs} args - Arguments to create many AuditEvents.
     * @example
     * // Create many AuditEvents
     * const auditEvent = await prisma.auditEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditEventCreateManyArgs>(args?: SelectSubset<T, AuditEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a AuditEvent.
     * @param {AuditEventDeleteArgs} args - Arguments to delete one AuditEvent.
     * @example
     * // Delete one AuditEvent
     * const AuditEvent = await prisma.auditEvent.delete({
     *   where: {
     *     // ... filter to delete one AuditEvent
     *   }
     * })
     * 
     */
    delete<T extends AuditEventDeleteArgs>(args: SelectSubset<T, AuditEventDeleteArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditEvent.
     * @param {AuditEventUpdateArgs} args - Arguments to update one AuditEvent.
     * @example
     * // Update one AuditEvent
     * const auditEvent = await prisma.auditEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditEventUpdateArgs>(args: SelectSubset<T, AuditEventUpdateArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditEvents.
     * @param {AuditEventDeleteManyArgs} args - Arguments to filter AuditEvents to delete.
     * @example
     * // Delete a few AuditEvents
     * const { count } = await prisma.auditEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditEventDeleteManyArgs>(args?: SelectSubset<T, AuditEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditEvents
     * const auditEvent = await prisma.auditEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditEventUpdateManyArgs>(args: SelectSubset<T, AuditEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditEvent.
     * @param {AuditEventUpsertArgs} args - Arguments to update or create a AuditEvent.
     * @example
     * // Update or create a AuditEvent
     * const auditEvent = await prisma.auditEvent.upsert({
     *   create: {
     *     // ... data to create a AuditEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditEvent we want to update
     *   }
     * })
     */
    upsert<T extends AuditEventUpsertArgs>(args: SelectSubset<T, AuditEventUpsertArgs<ExtArgs>>): Prisma__AuditEventClient<$Result.GetResult<Prisma.$AuditEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more AuditEvents that matches the filter.
     * @param {AuditEventFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const auditEvent = await prisma.auditEvent.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: AuditEventFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a AuditEvent.
     * @param {AuditEventAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const auditEvent = await prisma.auditEvent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: AuditEventAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of AuditEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventCountArgs} args - Arguments to filter AuditEvents to count.
     * @example
     * // Count the number of AuditEvents
     * const count = await prisma.auditEvent.count({
     *   where: {
     *     // ... the filter for the AuditEvents we want to count
     *   }
     * })
    **/
    count<T extends AuditEventCountArgs>(
      args?: Subset<T, AuditEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditEventAggregateArgs>(args: Subset<T, AuditEventAggregateArgs>): Prisma.PrismaPromise<GetAuditEventAggregateType<T>>

    /**
     * Group by AuditEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditEventGroupByArgs['orderBy'] }
        : { orderBy?: AuditEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditEvent model
   */
  readonly fields: AuditEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends AuditEvent$actorArgs<ExtArgs> = {}>(args?: Subset<T, AuditEvent$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditEvent model
   */ 
  interface AuditEventFieldRefs {
    readonly id: FieldRef<"AuditEvent", 'String'>
    readonly actorId: FieldRef<"AuditEvent", 'String'>
    readonly action: FieldRef<"AuditEvent", 'String'>
    readonly target: FieldRef<"AuditEvent", 'String'>
    readonly meta: FieldRef<"AuditEvent", 'Json'>
    readonly createdAt: FieldRef<"AuditEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditEvent findUnique
   */
  export type AuditEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findUniqueOrThrow
   */
  export type AuditEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent findFirst
   */
  export type AuditEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findFirstOrThrow
   */
  export type AuditEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvent to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditEvents.
     */
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent findMany
   */
  export type AuditEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter, which AuditEvents to fetch.
     */
    where?: AuditEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditEvents to fetch.
     */
    orderBy?: AuditEventOrderByWithRelationInput | AuditEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditEvents.
     */
    cursor?: AuditEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditEvents.
     */
    skip?: number
    distinct?: AuditEventScalarFieldEnum | AuditEventScalarFieldEnum[]
  }

  /**
   * AuditEvent create
   */
  export type AuditEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditEvent.
     */
    data: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
  }

  /**
   * AuditEvent createMany
   */
  export type AuditEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditEvents.
     */
    data: AuditEventCreateManyInput | AuditEventCreateManyInput[]
  }

  /**
   * AuditEvent update
   */
  export type AuditEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditEvent.
     */
    data: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
    /**
     * Choose, which AuditEvent to update.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent updateMany
   */
  export type AuditEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditEvents.
     */
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyInput>
    /**
     * Filter which AuditEvents to update
     */
    where?: AuditEventWhereInput
  }

  /**
   * AuditEvent upsert
   */
  export type AuditEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditEvent to update in case it exists.
     */
    where: AuditEventWhereUniqueInput
    /**
     * In case the AuditEvent found by the `where` argument doesn't exist, create a new AuditEvent with this data.
     */
    create: XOR<AuditEventCreateInput, AuditEventUncheckedCreateInput>
    /**
     * In case the AuditEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditEventUpdateInput, AuditEventUncheckedUpdateInput>
  }

  /**
   * AuditEvent delete
   */
  export type AuditEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
    /**
     * Filter which AuditEvent to delete.
     */
    where: AuditEventWhereUniqueInput
  }

  /**
   * AuditEvent deleteMany
   */
  export type AuditEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditEvents to delete
     */
    where?: AuditEventWhereInput
  }

  /**
   * AuditEvent findRaw
   */
  export type AuditEventFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AuditEvent aggregateRaw
   */
  export type AuditEventAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * AuditEvent.actor
   */
  export type AuditEvent$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditEvent without action
   */
  export type AuditEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditEvent
     */
    select?: AuditEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditEventInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    country: string | null
    type: $Enums.LeadType | null
    message: string | null
    status: $Enums.LeadStatus | null
    owner: string | null
    createdAt: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    company: string | null
    country: string | null
    type: $Enums.LeadType | null
    message: string | null
    status: $Enums.LeadStatus | null
    owner: string | null
    createdAt: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    company: number
    country: number
    type: number
    message: number
    tags: number
    status: number
    owner: number
    createdAt: number
    _all: number
  }


  export type LeadMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    country?: true
    type?: true
    message?: true
    status?: true
    owner?: true
    createdAt?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    country?: true
    type?: true
    message?: true
    status?: true
    owner?: true
    createdAt?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    company?: true
    country?: true
    type?: true
    message?: true
    tags?: true
    status?: true
    owner?: true
    createdAt?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    name: string
    email: string
    phone: string | null
    company: string | null
    country: string | null
    type: $Enums.LeadType
    message: string | null
    tags: string[]
    status: $Enums.LeadStatus
    owner: string | null
    createdAt: Date
    _count: LeadCountAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    country?: boolean
    type?: boolean
    message?: boolean
    tags?: boolean
    status?: boolean
    owner?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["lead"]>


  export type LeadSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    country?: boolean
    type?: boolean
    message?: boolean
    tags?: boolean
    status?: boolean
    owner?: boolean
    createdAt?: boolean
  }


  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      phone: string | null
      company: string | null
      country: string | null
      type: $Enums.LeadType
      message: string | null
      tags: string[]
      status: $Enums.LeadStatus
      owner: string | null
      createdAt: Date
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Leads that matches the filter.
     * @param {LeadFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const lead = await prisma.lead.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: LeadFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Lead.
     * @param {LeadAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const lead = await prisma.lead.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: LeadAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */ 
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly name: FieldRef<"Lead", 'String'>
    readonly email: FieldRef<"Lead", 'String'>
    readonly phone: FieldRef<"Lead", 'String'>
    readonly company: FieldRef<"Lead", 'String'>
    readonly country: FieldRef<"Lead", 'String'>
    readonly type: FieldRef<"Lead", 'LeadType'>
    readonly message: FieldRef<"Lead", 'String'>
    readonly tags: FieldRef<"Lead", 'String[]'>
    readonly status: FieldRef<"Lead", 'LeadStatus'>
    readonly owner: FieldRef<"Lead", 'String'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
  }

  /**
   * Lead findRaw
   */
  export type LeadFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Lead aggregateRaw
   */
  export type LeadAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
  }


  /**
   * Model Dealer
   */

  export type AggregateDealer = {
    _count: DealerCountAggregateOutputType | null
    _avg: DealerAvgAggregateOutputType | null
    _sum: DealerSumAggregateOutputType | null
    _min: DealerMinAggregateOutputType | null
    _max: DealerMaxAggregateOutputType | null
  }

  export type DealerAvgAggregateOutputType = {
    users: number | null
  }

  export type DealerSumAggregateOutputType = {
    users: number | null
  }

  export type DealerMinAggregateOutputType = {
    id: string | null
    org: string | null
    contactName: string | null
    contactEmail: string | null
    region: string | null
    status: $Enums.DealerStatus | null
    users: number | null
    last: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealerMaxAggregateOutputType = {
    id: string | null
    org: string | null
    contactName: string | null
    contactEmail: string | null
    region: string | null
    status: $Enums.DealerStatus | null
    users: number | null
    last: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealerCountAggregateOutputType = {
    id: number
    org: number
    contactName: number
    contactEmail: number
    region: number
    status: number
    users: number
    last: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DealerAvgAggregateInputType = {
    users?: true
  }

  export type DealerSumAggregateInputType = {
    users?: true
  }

  export type DealerMinAggregateInputType = {
    id?: true
    org?: true
    contactName?: true
    contactEmail?: true
    region?: true
    status?: true
    users?: true
    last?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealerMaxAggregateInputType = {
    id?: true
    org?: true
    contactName?: true
    contactEmail?: true
    region?: true
    status?: true
    users?: true
    last?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealerCountAggregateInputType = {
    id?: true
    org?: true
    contactName?: true
    contactEmail?: true
    region?: true
    status?: true
    users?: true
    last?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DealerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dealer to aggregate.
     */
    where?: DealerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealers to fetch.
     */
    orderBy?: DealerOrderByWithRelationInput | DealerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dealers
    **/
    _count?: true | DealerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealerMaxAggregateInputType
  }

  export type GetDealerAggregateType<T extends DealerAggregateArgs> = {
        [P in keyof T & keyof AggregateDealer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDealer[P]>
      : GetScalarType<T[P], AggregateDealer[P]>
  }




  export type DealerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealerWhereInput
    orderBy?: DealerOrderByWithAggregationInput | DealerOrderByWithAggregationInput[]
    by: DealerScalarFieldEnum[] | DealerScalarFieldEnum
    having?: DealerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealerCountAggregateInputType | true
    _avg?: DealerAvgAggregateInputType
    _sum?: DealerSumAggregateInputType
    _min?: DealerMinAggregateInputType
    _max?: DealerMaxAggregateInputType
  }

  export type DealerGroupByOutputType = {
    id: string
    org: string
    contactName: string
    contactEmail: string
    region: string
    status: $Enums.DealerStatus
    users: number
    last: Date
    createdAt: Date
    updatedAt: Date
    _count: DealerCountAggregateOutputType | null
    _avg: DealerAvgAggregateOutputType | null
    _sum: DealerSumAggregateOutputType | null
    _min: DealerMinAggregateOutputType | null
    _max: DealerMaxAggregateOutputType | null
  }

  type GetDealerGroupByPayload<T extends DealerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealerGroupByOutputType[P]>
            : GetScalarType<T[P], DealerGroupByOutputType[P]>
        }
      >
    >


  export type DealerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    org?: boolean
    contactName?: boolean
    contactEmail?: boolean
    region?: boolean
    status?: boolean
    users?: boolean
    last?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["dealer"]>


  export type DealerSelectScalar = {
    id?: boolean
    org?: boolean
    contactName?: boolean
    contactEmail?: boolean
    region?: boolean
    status?: boolean
    users?: boolean
    last?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $DealerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dealer"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      org: string
      contactName: string
      contactEmail: string
      region: string
      status: $Enums.DealerStatus
      users: number
      last: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dealer"]>
    composites: {}
  }

  type DealerGetPayload<S extends boolean | null | undefined | DealerDefaultArgs> = $Result.GetResult<Prisma.$DealerPayload, S>

  type DealerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DealerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DealerCountAggregateInputType | true
    }

  export interface DealerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dealer'], meta: { name: 'Dealer' } }
    /**
     * Find zero or one Dealer that matches the filter.
     * @param {DealerFindUniqueArgs} args - Arguments to find a Dealer
     * @example
     * // Get one Dealer
     * const dealer = await prisma.dealer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealerFindUniqueArgs>(args: SelectSubset<T, DealerFindUniqueArgs<ExtArgs>>): Prisma__DealerClient<$Result.GetResult<Prisma.$DealerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dealer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DealerFindUniqueOrThrowArgs} args - Arguments to find a Dealer
     * @example
     * // Get one Dealer
     * const dealer = await prisma.dealer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealerFindUniqueOrThrowArgs>(args: SelectSubset<T, DealerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealerClient<$Result.GetResult<Prisma.$DealerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dealer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerFindFirstArgs} args - Arguments to find a Dealer
     * @example
     * // Get one Dealer
     * const dealer = await prisma.dealer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealerFindFirstArgs>(args?: SelectSubset<T, DealerFindFirstArgs<ExtArgs>>): Prisma__DealerClient<$Result.GetResult<Prisma.$DealerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dealer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerFindFirstOrThrowArgs} args - Arguments to find a Dealer
     * @example
     * // Get one Dealer
     * const dealer = await prisma.dealer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealerFindFirstOrThrowArgs>(args?: SelectSubset<T, DealerFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealerClient<$Result.GetResult<Prisma.$DealerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dealers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dealers
     * const dealers = await prisma.dealer.findMany()
     * 
     * // Get first 10 Dealers
     * const dealers = await prisma.dealer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealerWithIdOnly = await prisma.dealer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealerFindManyArgs>(args?: SelectSubset<T, DealerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dealer.
     * @param {DealerCreateArgs} args - Arguments to create a Dealer.
     * @example
     * // Create one Dealer
     * const Dealer = await prisma.dealer.create({
     *   data: {
     *     // ... data to create a Dealer
     *   }
     * })
     * 
     */
    create<T extends DealerCreateArgs>(args: SelectSubset<T, DealerCreateArgs<ExtArgs>>): Prisma__DealerClient<$Result.GetResult<Prisma.$DealerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dealers.
     * @param {DealerCreateManyArgs} args - Arguments to create many Dealers.
     * @example
     * // Create many Dealers
     * const dealer = await prisma.dealer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealerCreateManyArgs>(args?: SelectSubset<T, DealerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dealer.
     * @param {DealerDeleteArgs} args - Arguments to delete one Dealer.
     * @example
     * // Delete one Dealer
     * const Dealer = await prisma.dealer.delete({
     *   where: {
     *     // ... filter to delete one Dealer
     *   }
     * })
     * 
     */
    delete<T extends DealerDeleteArgs>(args: SelectSubset<T, DealerDeleteArgs<ExtArgs>>): Prisma__DealerClient<$Result.GetResult<Prisma.$DealerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dealer.
     * @param {DealerUpdateArgs} args - Arguments to update one Dealer.
     * @example
     * // Update one Dealer
     * const dealer = await prisma.dealer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealerUpdateArgs>(args: SelectSubset<T, DealerUpdateArgs<ExtArgs>>): Prisma__DealerClient<$Result.GetResult<Prisma.$DealerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dealers.
     * @param {DealerDeleteManyArgs} args - Arguments to filter Dealers to delete.
     * @example
     * // Delete a few Dealers
     * const { count } = await prisma.dealer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealerDeleteManyArgs>(args?: SelectSubset<T, DealerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dealers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dealers
     * const dealer = await prisma.dealer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealerUpdateManyArgs>(args: SelectSubset<T, DealerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dealer.
     * @param {DealerUpsertArgs} args - Arguments to update or create a Dealer.
     * @example
     * // Update or create a Dealer
     * const dealer = await prisma.dealer.upsert({
     *   create: {
     *     // ... data to create a Dealer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dealer we want to update
     *   }
     * })
     */
    upsert<T extends DealerUpsertArgs>(args: SelectSubset<T, DealerUpsertArgs<ExtArgs>>): Prisma__DealerClient<$Result.GetResult<Prisma.$DealerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Dealers that matches the filter.
     * @param {DealerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dealer = await prisma.dealer.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DealerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Dealer.
     * @param {DealerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dealer = await prisma.dealer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DealerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Dealers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerCountArgs} args - Arguments to filter Dealers to count.
     * @example
     * // Count the number of Dealers
     * const count = await prisma.dealer.count({
     *   where: {
     *     // ... the filter for the Dealers we want to count
     *   }
     * })
    **/
    count<T extends DealerCountArgs>(
      args?: Subset<T, DealerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dealer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealerAggregateArgs>(args: Subset<T, DealerAggregateArgs>): Prisma.PrismaPromise<GetDealerAggregateType<T>>

    /**
     * Group by Dealer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealerGroupByArgs['orderBy'] }
        : { orderBy?: DealerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dealer model
   */
  readonly fields: DealerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dealer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dealer model
   */ 
  interface DealerFieldRefs {
    readonly id: FieldRef<"Dealer", 'String'>
    readonly org: FieldRef<"Dealer", 'String'>
    readonly contactName: FieldRef<"Dealer", 'String'>
    readonly contactEmail: FieldRef<"Dealer", 'String'>
    readonly region: FieldRef<"Dealer", 'String'>
    readonly status: FieldRef<"Dealer", 'DealerStatus'>
    readonly users: FieldRef<"Dealer", 'Int'>
    readonly last: FieldRef<"Dealer", 'DateTime'>
    readonly createdAt: FieldRef<"Dealer", 'DateTime'>
    readonly updatedAt: FieldRef<"Dealer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Dealer findUnique
   */
  export type DealerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealer
     */
    select?: DealerSelect<ExtArgs> | null
    /**
     * Filter, which Dealer to fetch.
     */
    where: DealerWhereUniqueInput
  }

  /**
   * Dealer findUniqueOrThrow
   */
  export type DealerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealer
     */
    select?: DealerSelect<ExtArgs> | null
    /**
     * Filter, which Dealer to fetch.
     */
    where: DealerWhereUniqueInput
  }

  /**
   * Dealer findFirst
   */
  export type DealerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealer
     */
    select?: DealerSelect<ExtArgs> | null
    /**
     * Filter, which Dealer to fetch.
     */
    where?: DealerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealers to fetch.
     */
    orderBy?: DealerOrderByWithRelationInput | DealerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dealers.
     */
    cursor?: DealerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dealers.
     */
    distinct?: DealerScalarFieldEnum | DealerScalarFieldEnum[]
  }

  /**
   * Dealer findFirstOrThrow
   */
  export type DealerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealer
     */
    select?: DealerSelect<ExtArgs> | null
    /**
     * Filter, which Dealer to fetch.
     */
    where?: DealerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealers to fetch.
     */
    orderBy?: DealerOrderByWithRelationInput | DealerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dealers.
     */
    cursor?: DealerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dealers.
     */
    distinct?: DealerScalarFieldEnum | DealerScalarFieldEnum[]
  }

  /**
   * Dealer findMany
   */
  export type DealerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealer
     */
    select?: DealerSelect<ExtArgs> | null
    /**
     * Filter, which Dealers to fetch.
     */
    where?: DealerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dealers to fetch.
     */
    orderBy?: DealerOrderByWithRelationInput | DealerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dealers.
     */
    cursor?: DealerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dealers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dealers.
     */
    skip?: number
    distinct?: DealerScalarFieldEnum | DealerScalarFieldEnum[]
  }

  /**
   * Dealer create
   */
  export type DealerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealer
     */
    select?: DealerSelect<ExtArgs> | null
    /**
     * The data needed to create a Dealer.
     */
    data: XOR<DealerCreateInput, DealerUncheckedCreateInput>
  }

  /**
   * Dealer createMany
   */
  export type DealerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dealers.
     */
    data: DealerCreateManyInput | DealerCreateManyInput[]
  }

  /**
   * Dealer update
   */
  export type DealerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealer
     */
    select?: DealerSelect<ExtArgs> | null
    /**
     * The data needed to update a Dealer.
     */
    data: XOR<DealerUpdateInput, DealerUncheckedUpdateInput>
    /**
     * Choose, which Dealer to update.
     */
    where: DealerWhereUniqueInput
  }

  /**
   * Dealer updateMany
   */
  export type DealerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dealers.
     */
    data: XOR<DealerUpdateManyMutationInput, DealerUncheckedUpdateManyInput>
    /**
     * Filter which Dealers to update
     */
    where?: DealerWhereInput
  }

  /**
   * Dealer upsert
   */
  export type DealerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealer
     */
    select?: DealerSelect<ExtArgs> | null
    /**
     * The filter to search for the Dealer to update in case it exists.
     */
    where: DealerWhereUniqueInput
    /**
     * In case the Dealer found by the `where` argument doesn't exist, create a new Dealer with this data.
     */
    create: XOR<DealerCreateInput, DealerUncheckedCreateInput>
    /**
     * In case the Dealer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealerUpdateInput, DealerUncheckedUpdateInput>
  }

  /**
   * Dealer delete
   */
  export type DealerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealer
     */
    select?: DealerSelect<ExtArgs> | null
    /**
     * Filter which Dealer to delete.
     */
    where: DealerWhereUniqueInput
  }

  /**
   * Dealer deleteMany
   */
  export type DealerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dealers to delete
     */
    where?: DealerWhereInput
  }

  /**
   * Dealer findRaw
   */
  export type DealerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Dealer aggregateRaw
   */
  export type DealerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Dealer without action
   */
  export type DealerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dealer
     */
    select?: DealerSelect<ExtArgs> | null
  }


  /**
   * Model FileAsset
   */

  export type AggregateFileAsset = {
    _count: FileAssetCountAggregateOutputType | null
    _avg: FileAssetAvgAggregateOutputType | null
    _sum: FileAssetSumAggregateOutputType | null
    _min: FileAssetMinAggregateOutputType | null
    _max: FileAssetMaxAggregateOutputType | null
  }

  export type FileAssetAvgAggregateOutputType = {
    size: number | null
  }

  export type FileAssetSumAggregateOutputType = {
    size: number | null
  }

  export type FileAssetMinAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.FileType | null
    cat: $Enums.FileCategory | null
    vis: $Enums.FileVisibility | null
    url: string | null
    desc: string | null
    size: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileAssetMaxAggregateOutputType = {
    id: string | null
    name: string | null
    type: $Enums.FileType | null
    cat: $Enums.FileCategory | null
    vis: $Enums.FileVisibility | null
    url: string | null
    desc: string | null
    size: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileAssetCountAggregateOutputType = {
    id: number
    name: number
    type: number
    cat: number
    vis: number
    url: number
    desc: number
    size: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FileAssetAvgAggregateInputType = {
    size?: true
  }

  export type FileAssetSumAggregateInputType = {
    size?: true
  }

  export type FileAssetMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    cat?: true
    vis?: true
    url?: true
    desc?: true
    size?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileAssetMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    cat?: true
    vis?: true
    url?: true
    desc?: true
    size?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileAssetCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    cat?: true
    vis?: true
    url?: true
    desc?: true
    size?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FileAssetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileAsset to aggregate.
     */
    where?: FileAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAssets to fetch.
     */
    orderBy?: FileAssetOrderByWithRelationInput | FileAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileAssets
    **/
    _count?: true | FileAssetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAssetAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileAssetSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileAssetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileAssetMaxAggregateInputType
  }

  export type GetFileAssetAggregateType<T extends FileAssetAggregateArgs> = {
        [P in keyof T & keyof AggregateFileAsset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileAsset[P]>
      : GetScalarType<T[P], AggregateFileAsset[P]>
  }




  export type FileAssetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileAssetWhereInput
    orderBy?: FileAssetOrderByWithAggregationInput | FileAssetOrderByWithAggregationInput[]
    by: FileAssetScalarFieldEnum[] | FileAssetScalarFieldEnum
    having?: FileAssetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileAssetCountAggregateInputType | true
    _avg?: FileAssetAvgAggregateInputType
    _sum?: FileAssetSumAggregateInputType
    _min?: FileAssetMinAggregateInputType
    _max?: FileAssetMaxAggregateInputType
  }

  export type FileAssetGroupByOutputType = {
    id: string
    name: string
    type: $Enums.FileType
    cat: $Enums.FileCategory
    vis: $Enums.FileVisibility
    url: string
    desc: string | null
    size: number | null
    createdAt: Date
    updatedAt: Date
    _count: FileAssetCountAggregateOutputType | null
    _avg: FileAssetAvgAggregateOutputType | null
    _sum: FileAssetSumAggregateOutputType | null
    _min: FileAssetMinAggregateOutputType | null
    _max: FileAssetMaxAggregateOutputType | null
  }

  type GetFileAssetGroupByPayload<T extends FileAssetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileAssetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileAssetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileAssetGroupByOutputType[P]>
            : GetScalarType<T[P], FileAssetGroupByOutputType[P]>
        }
      >
    >


  export type FileAssetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    cat?: boolean
    vis?: boolean
    url?: boolean
    desc?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["fileAsset"]>


  export type FileAssetSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    cat?: boolean
    vis?: boolean
    url?: boolean
    desc?: boolean
    size?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $FileAssetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileAsset"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      type: $Enums.FileType
      cat: $Enums.FileCategory
      vis: $Enums.FileVisibility
      url: string
      desc: string | null
      size: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["fileAsset"]>
    composites: {}
  }

  type FileAssetGetPayload<S extends boolean | null | undefined | FileAssetDefaultArgs> = $Result.GetResult<Prisma.$FileAssetPayload, S>

  type FileAssetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FileAssetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FileAssetCountAggregateInputType | true
    }

  export interface FileAssetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileAsset'], meta: { name: 'FileAsset' } }
    /**
     * Find zero or one FileAsset that matches the filter.
     * @param {FileAssetFindUniqueArgs} args - Arguments to find a FileAsset
     * @example
     * // Get one FileAsset
     * const fileAsset = await prisma.fileAsset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileAssetFindUniqueArgs>(args: SelectSubset<T, FileAssetFindUniqueArgs<ExtArgs>>): Prisma__FileAssetClient<$Result.GetResult<Prisma.$FileAssetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FileAsset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FileAssetFindUniqueOrThrowArgs} args - Arguments to find a FileAsset
     * @example
     * // Get one FileAsset
     * const fileAsset = await prisma.fileAsset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileAssetFindUniqueOrThrowArgs>(args: SelectSubset<T, FileAssetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileAssetClient<$Result.GetResult<Prisma.$FileAssetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FileAsset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssetFindFirstArgs} args - Arguments to find a FileAsset
     * @example
     * // Get one FileAsset
     * const fileAsset = await prisma.fileAsset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileAssetFindFirstArgs>(args?: SelectSubset<T, FileAssetFindFirstArgs<ExtArgs>>): Prisma__FileAssetClient<$Result.GetResult<Prisma.$FileAssetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FileAsset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssetFindFirstOrThrowArgs} args - Arguments to find a FileAsset
     * @example
     * // Get one FileAsset
     * const fileAsset = await prisma.fileAsset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileAssetFindFirstOrThrowArgs>(args?: SelectSubset<T, FileAssetFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileAssetClient<$Result.GetResult<Prisma.$FileAssetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FileAssets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileAssets
     * const fileAssets = await prisma.fileAsset.findMany()
     * 
     * // Get first 10 FileAssets
     * const fileAssets = await prisma.fileAsset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileAssetWithIdOnly = await prisma.fileAsset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileAssetFindManyArgs>(args?: SelectSubset<T, FileAssetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileAssetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FileAsset.
     * @param {FileAssetCreateArgs} args - Arguments to create a FileAsset.
     * @example
     * // Create one FileAsset
     * const FileAsset = await prisma.fileAsset.create({
     *   data: {
     *     // ... data to create a FileAsset
     *   }
     * })
     * 
     */
    create<T extends FileAssetCreateArgs>(args: SelectSubset<T, FileAssetCreateArgs<ExtArgs>>): Prisma__FileAssetClient<$Result.GetResult<Prisma.$FileAssetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FileAssets.
     * @param {FileAssetCreateManyArgs} args - Arguments to create many FileAssets.
     * @example
     * // Create many FileAssets
     * const fileAsset = await prisma.fileAsset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileAssetCreateManyArgs>(args?: SelectSubset<T, FileAssetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FileAsset.
     * @param {FileAssetDeleteArgs} args - Arguments to delete one FileAsset.
     * @example
     * // Delete one FileAsset
     * const FileAsset = await prisma.fileAsset.delete({
     *   where: {
     *     // ... filter to delete one FileAsset
     *   }
     * })
     * 
     */
    delete<T extends FileAssetDeleteArgs>(args: SelectSubset<T, FileAssetDeleteArgs<ExtArgs>>): Prisma__FileAssetClient<$Result.GetResult<Prisma.$FileAssetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FileAsset.
     * @param {FileAssetUpdateArgs} args - Arguments to update one FileAsset.
     * @example
     * // Update one FileAsset
     * const fileAsset = await prisma.fileAsset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileAssetUpdateArgs>(args: SelectSubset<T, FileAssetUpdateArgs<ExtArgs>>): Prisma__FileAssetClient<$Result.GetResult<Prisma.$FileAssetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FileAssets.
     * @param {FileAssetDeleteManyArgs} args - Arguments to filter FileAssets to delete.
     * @example
     * // Delete a few FileAssets
     * const { count } = await prisma.fileAsset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileAssetDeleteManyArgs>(args?: SelectSubset<T, FileAssetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileAssets
     * const fileAsset = await prisma.fileAsset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileAssetUpdateManyArgs>(args: SelectSubset<T, FileAssetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FileAsset.
     * @param {FileAssetUpsertArgs} args - Arguments to update or create a FileAsset.
     * @example
     * // Update or create a FileAsset
     * const fileAsset = await prisma.fileAsset.upsert({
     *   create: {
     *     // ... data to create a FileAsset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileAsset we want to update
     *   }
     * })
     */
    upsert<T extends FileAssetUpsertArgs>(args: SelectSubset<T, FileAssetUpsertArgs<ExtArgs>>): Prisma__FileAssetClient<$Result.GetResult<Prisma.$FileAssetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more FileAssets that matches the filter.
     * @param {FileAssetFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const fileAsset = await prisma.fileAsset.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: FileAssetFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a FileAsset.
     * @param {FileAssetAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const fileAsset = await prisma.fileAsset.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: FileAssetAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of FileAssets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssetCountArgs} args - Arguments to filter FileAssets to count.
     * @example
     * // Count the number of FileAssets
     * const count = await prisma.fileAsset.count({
     *   where: {
     *     // ... the filter for the FileAssets we want to count
     *   }
     * })
    **/
    count<T extends FileAssetCountArgs>(
      args?: Subset<T, FileAssetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileAssetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAssetAggregateArgs>(args: Subset<T, FileAssetAggregateArgs>): Prisma.PrismaPromise<GetFileAssetAggregateType<T>>

    /**
     * Group by FileAsset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAssetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileAssetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileAssetGroupByArgs['orderBy'] }
        : { orderBy?: FileAssetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileAssetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileAssetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileAsset model
   */
  readonly fields: FileAssetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileAsset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileAssetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileAsset model
   */ 
  interface FileAssetFieldRefs {
    readonly id: FieldRef<"FileAsset", 'String'>
    readonly name: FieldRef<"FileAsset", 'String'>
    readonly type: FieldRef<"FileAsset", 'FileType'>
    readonly cat: FieldRef<"FileAsset", 'FileCategory'>
    readonly vis: FieldRef<"FileAsset", 'FileVisibility'>
    readonly url: FieldRef<"FileAsset", 'String'>
    readonly desc: FieldRef<"FileAsset", 'String'>
    readonly size: FieldRef<"FileAsset", 'Int'>
    readonly createdAt: FieldRef<"FileAsset", 'DateTime'>
    readonly updatedAt: FieldRef<"FileAsset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileAsset findUnique
   */
  export type FileAssetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAsset
     */
    select?: FileAssetSelect<ExtArgs> | null
    /**
     * Filter, which FileAsset to fetch.
     */
    where: FileAssetWhereUniqueInput
  }

  /**
   * FileAsset findUniqueOrThrow
   */
  export type FileAssetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAsset
     */
    select?: FileAssetSelect<ExtArgs> | null
    /**
     * Filter, which FileAsset to fetch.
     */
    where: FileAssetWhereUniqueInput
  }

  /**
   * FileAsset findFirst
   */
  export type FileAssetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAsset
     */
    select?: FileAssetSelect<ExtArgs> | null
    /**
     * Filter, which FileAsset to fetch.
     */
    where?: FileAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAssets to fetch.
     */
    orderBy?: FileAssetOrderByWithRelationInput | FileAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileAssets.
     */
    cursor?: FileAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileAssets.
     */
    distinct?: FileAssetScalarFieldEnum | FileAssetScalarFieldEnum[]
  }

  /**
   * FileAsset findFirstOrThrow
   */
  export type FileAssetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAsset
     */
    select?: FileAssetSelect<ExtArgs> | null
    /**
     * Filter, which FileAsset to fetch.
     */
    where?: FileAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAssets to fetch.
     */
    orderBy?: FileAssetOrderByWithRelationInput | FileAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileAssets.
     */
    cursor?: FileAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAssets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileAssets.
     */
    distinct?: FileAssetScalarFieldEnum | FileAssetScalarFieldEnum[]
  }

  /**
   * FileAsset findMany
   */
  export type FileAssetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAsset
     */
    select?: FileAssetSelect<ExtArgs> | null
    /**
     * Filter, which FileAssets to fetch.
     */
    where?: FileAssetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileAssets to fetch.
     */
    orderBy?: FileAssetOrderByWithRelationInput | FileAssetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileAssets.
     */
    cursor?: FileAssetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileAssets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileAssets.
     */
    skip?: number
    distinct?: FileAssetScalarFieldEnum | FileAssetScalarFieldEnum[]
  }

  /**
   * FileAsset create
   */
  export type FileAssetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAsset
     */
    select?: FileAssetSelect<ExtArgs> | null
    /**
     * The data needed to create a FileAsset.
     */
    data: XOR<FileAssetCreateInput, FileAssetUncheckedCreateInput>
  }

  /**
   * FileAsset createMany
   */
  export type FileAssetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileAssets.
     */
    data: FileAssetCreateManyInput | FileAssetCreateManyInput[]
  }

  /**
   * FileAsset update
   */
  export type FileAssetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAsset
     */
    select?: FileAssetSelect<ExtArgs> | null
    /**
     * The data needed to update a FileAsset.
     */
    data: XOR<FileAssetUpdateInput, FileAssetUncheckedUpdateInput>
    /**
     * Choose, which FileAsset to update.
     */
    where: FileAssetWhereUniqueInput
  }

  /**
   * FileAsset updateMany
   */
  export type FileAssetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileAssets.
     */
    data: XOR<FileAssetUpdateManyMutationInput, FileAssetUncheckedUpdateManyInput>
    /**
     * Filter which FileAssets to update
     */
    where?: FileAssetWhereInput
  }

  /**
   * FileAsset upsert
   */
  export type FileAssetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAsset
     */
    select?: FileAssetSelect<ExtArgs> | null
    /**
     * The filter to search for the FileAsset to update in case it exists.
     */
    where: FileAssetWhereUniqueInput
    /**
     * In case the FileAsset found by the `where` argument doesn't exist, create a new FileAsset with this data.
     */
    create: XOR<FileAssetCreateInput, FileAssetUncheckedCreateInput>
    /**
     * In case the FileAsset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileAssetUpdateInput, FileAssetUncheckedUpdateInput>
  }

  /**
   * FileAsset delete
   */
  export type FileAssetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAsset
     */
    select?: FileAssetSelect<ExtArgs> | null
    /**
     * Filter which FileAsset to delete.
     */
    where: FileAssetWhereUniqueInput
  }

  /**
   * FileAsset deleteMany
   */
  export type FileAssetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileAssets to delete
     */
    where?: FileAssetWhereInput
  }

  /**
   * FileAsset findRaw
   */
  export type FileAssetFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FileAsset aggregateRaw
   */
  export type FileAssetAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * FileAsset without action
   */
  export type FileAssetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileAsset
     */
    select?: FileAssetSelect<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    variant: string | null
    short: string | null
    long: string | null
    bullets: string | null
    nij: string | null
    thickness: string | null
    vlt: string | null
    impact: string | null
    datasheet: string | null
    slug: string | null
    metaTitle: string | null
    metaDesc: string | null
    status: $Enums.ProductStatus | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    code: string | null
    variant: string | null
    short: string | null
    long: string | null
    bullets: string | null
    nij: string | null
    thickness: string | null
    vlt: string | null
    impact: string | null
    datasheet: string | null
    slug: string | null
    metaTitle: string | null
    metaDesc: string | null
    status: $Enums.ProductStatus | null
    updatedAt: Date | null
    createdAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    code: number
    variant: number
    short: number
    long: number
    bullets: number
    nij: number
    thickness: number
    vlt: number
    impact: number
    images: number
    datasheet: number
    slug: number
    metaTitle: number
    metaDesc: number
    status: number
    updatedAt: number
    createdAt: number
    _all: number
  }


  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    code?: true
    variant?: true
    short?: true
    long?: true
    bullets?: true
    nij?: true
    thickness?: true
    vlt?: true
    impact?: true
    datasheet?: true
    slug?: true
    metaTitle?: true
    metaDesc?: true
    status?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    code?: true
    variant?: true
    short?: true
    long?: true
    bullets?: true
    nij?: true
    thickness?: true
    vlt?: true
    impact?: true
    datasheet?: true
    slug?: true
    metaTitle?: true
    metaDesc?: true
    status?: true
    updatedAt?: true
    createdAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    code?: true
    variant?: true
    short?: true
    long?: true
    bullets?: true
    nij?: true
    thickness?: true
    vlt?: true
    impact?: true
    images?: true
    datasheet?: true
    slug?: true
    metaTitle?: true
    metaDesc?: true
    status?: true
    updatedAt?: true
    createdAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    code: string | null
    variant: string | null
    short: string | null
    long: string | null
    bullets: string | null
    nij: string | null
    thickness: string | null
    vlt: string | null
    impact: string | null
    images: string[]
    datasheet: string | null
    slug: string
    metaTitle: string | null
    metaDesc: string | null
    status: $Enums.ProductStatus
    updatedAt: Date
    createdAt: Date
    _count: ProductCountAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    code?: boolean
    variant?: boolean
    short?: boolean
    long?: boolean
    bullets?: boolean
    nij?: boolean
    thickness?: boolean
    vlt?: boolean
    impact?: boolean
    images?: boolean
    datasheet?: boolean
    slug?: boolean
    metaTitle?: boolean
    metaDesc?: boolean
    status?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["product"]>


  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    code?: boolean
    variant?: boolean
    short?: boolean
    long?: boolean
    bullets?: boolean
    nij?: boolean
    thickness?: boolean
    vlt?: boolean
    impact?: boolean
    images?: boolean
    datasheet?: boolean
    slug?: boolean
    metaTitle?: boolean
    metaDesc?: boolean
    status?: boolean
    updatedAt?: boolean
    createdAt?: boolean
  }


  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      code: string | null
      variant: string | null
      short: string | null
      long: string | null
      bullets: string | null
      nij: string | null
      thickness: string | null
      vlt: string | null
      impact: string | null
      images: string[]
      datasheet: string | null
      slug: string
      metaTitle: string | null
      metaDesc: string | null
      status: $Enums.ProductStatus
      updatedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * @param {ProductFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const product = await prisma.product.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: ProductFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Product.
     * @param {ProductAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const product = await prisma.product.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ProductAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly code: FieldRef<"Product", 'String'>
    readonly variant: FieldRef<"Product", 'String'>
    readonly short: FieldRef<"Product", 'String'>
    readonly long: FieldRef<"Product", 'String'>
    readonly bullets: FieldRef<"Product", 'String'>
    readonly nij: FieldRef<"Product", 'String'>
    readonly thickness: FieldRef<"Product", 'String'>
    readonly vlt: FieldRef<"Product", 'String'>
    readonly impact: FieldRef<"Product", 'String'>
    readonly images: FieldRef<"Product", 'String[]'>
    readonly datasheet: FieldRef<"Product", 'String'>
    readonly slug: FieldRef<"Product", 'String'>
    readonly metaTitle: FieldRef<"Product", 'String'>
    readonly metaDesc: FieldRef<"Product", 'String'>
    readonly status: FieldRef<"Product", 'ProductStatus'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product findRaw
   */
  export type ProductFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Product aggregateRaw
   */
  export type ProductAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
  }


  /**
   * Model DealerUpload
   */

  export type AggregateDealerUpload = {
    _count: DealerUploadCountAggregateOutputType | null
    _min: DealerUploadMinAggregateOutputType | null
    _max: DealerUploadMaxAggregateOutputType | null
  }

  export type DealerUploadMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    name: string | null
    category: string | null
    description: string | null
    status: $Enums.DealerUploadStatus | null
    reviewerId: string | null
    reviewNote: string | null
    createdAt: Date | null
    reviewedAt: Date | null
  }

  export type DealerUploadMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    name: string | null
    category: string | null
    description: string | null
    status: $Enums.DealerUploadStatus | null
    reviewerId: string | null
    reviewNote: string | null
    createdAt: Date | null
    reviewedAt: Date | null
  }

  export type DealerUploadCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    name: number
    category: number
    description: number
    status: number
    reviewerId: number
    reviewNote: number
    createdAt: number
    reviewedAt: number
    _all: number
  }


  export type DealerUploadMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    category?: true
    description?: true
    status?: true
    reviewerId?: true
    reviewNote?: true
    createdAt?: true
    reviewedAt?: true
  }

  export type DealerUploadMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    category?: true
    description?: true
    status?: true
    reviewerId?: true
    reviewNote?: true
    createdAt?: true
    reviewedAt?: true
  }

  export type DealerUploadCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    category?: true
    description?: true
    status?: true
    reviewerId?: true
    reviewNote?: true
    createdAt?: true
    reviewedAt?: true
    _all?: true
  }

  export type DealerUploadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealerUpload to aggregate.
     */
    where?: DealerUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealerUploads to fetch.
     */
    orderBy?: DealerUploadOrderByWithRelationInput | DealerUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealerUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealerUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealerUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DealerUploads
    **/
    _count?: true | DealerUploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealerUploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealerUploadMaxAggregateInputType
  }

  export type GetDealerUploadAggregateType<T extends DealerUploadAggregateArgs> = {
        [P in keyof T & keyof AggregateDealerUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDealerUpload[P]>
      : GetScalarType<T[P], AggregateDealerUpload[P]>
  }




  export type DealerUploadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealerUploadWhereInput
    orderBy?: DealerUploadOrderByWithAggregationInput | DealerUploadOrderByWithAggregationInput[]
    by: DealerUploadScalarFieldEnum[] | DealerUploadScalarFieldEnum
    having?: DealerUploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealerUploadCountAggregateInputType | true
    _min?: DealerUploadMinAggregateInputType
    _max?: DealerUploadMaxAggregateInputType
  }

  export type DealerUploadGroupByOutputType = {
    id: string
    userId: string
    email: string
    name: string
    category: string
    description: string | null
    status: $Enums.DealerUploadStatus
    reviewerId: string | null
    reviewNote: string | null
    createdAt: Date
    reviewedAt: Date | null
    _count: DealerUploadCountAggregateOutputType | null
    _min: DealerUploadMinAggregateOutputType | null
    _max: DealerUploadMaxAggregateOutputType | null
  }

  type GetDealerUploadGroupByPayload<T extends DealerUploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealerUploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealerUploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealerUploadGroupByOutputType[P]>
            : GetScalarType<T[P], DealerUploadGroupByOutputType[P]>
        }
      >
    >


  export type DealerUploadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    status?: boolean
    reviewerId?: boolean
    reviewNote?: boolean
    createdAt?: boolean
    reviewedAt?: boolean
  }, ExtArgs["result"]["dealerUpload"]>


  export type DealerUploadSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    category?: boolean
    description?: boolean
    status?: boolean
    reviewerId?: boolean
    reviewNote?: boolean
    createdAt?: boolean
    reviewedAt?: boolean
  }


  export type $DealerUploadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DealerUpload"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      email: string
      name: string
      category: string
      description: string | null
      status: $Enums.DealerUploadStatus
      reviewerId: string | null
      reviewNote: string | null
      createdAt: Date
      reviewedAt: Date | null
    }, ExtArgs["result"]["dealerUpload"]>
    composites: {}
  }

  type DealerUploadGetPayload<S extends boolean | null | undefined | DealerUploadDefaultArgs> = $Result.GetResult<Prisma.$DealerUploadPayload, S>

  type DealerUploadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DealerUploadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DealerUploadCountAggregateInputType | true
    }

  export interface DealerUploadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DealerUpload'], meta: { name: 'DealerUpload' } }
    /**
     * Find zero or one DealerUpload that matches the filter.
     * @param {DealerUploadFindUniqueArgs} args - Arguments to find a DealerUpload
     * @example
     * // Get one DealerUpload
     * const dealerUpload = await prisma.dealerUpload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealerUploadFindUniqueArgs>(args: SelectSubset<T, DealerUploadFindUniqueArgs<ExtArgs>>): Prisma__DealerUploadClient<$Result.GetResult<Prisma.$DealerUploadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DealerUpload that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DealerUploadFindUniqueOrThrowArgs} args - Arguments to find a DealerUpload
     * @example
     * // Get one DealerUpload
     * const dealerUpload = await prisma.dealerUpload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealerUploadFindUniqueOrThrowArgs>(args: SelectSubset<T, DealerUploadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealerUploadClient<$Result.GetResult<Prisma.$DealerUploadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DealerUpload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerUploadFindFirstArgs} args - Arguments to find a DealerUpload
     * @example
     * // Get one DealerUpload
     * const dealerUpload = await prisma.dealerUpload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealerUploadFindFirstArgs>(args?: SelectSubset<T, DealerUploadFindFirstArgs<ExtArgs>>): Prisma__DealerUploadClient<$Result.GetResult<Prisma.$DealerUploadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DealerUpload that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerUploadFindFirstOrThrowArgs} args - Arguments to find a DealerUpload
     * @example
     * // Get one DealerUpload
     * const dealerUpload = await prisma.dealerUpload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealerUploadFindFirstOrThrowArgs>(args?: SelectSubset<T, DealerUploadFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealerUploadClient<$Result.GetResult<Prisma.$DealerUploadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DealerUploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerUploadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DealerUploads
     * const dealerUploads = await prisma.dealerUpload.findMany()
     * 
     * // Get first 10 DealerUploads
     * const dealerUploads = await prisma.dealerUpload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealerUploadWithIdOnly = await prisma.dealerUpload.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealerUploadFindManyArgs>(args?: SelectSubset<T, DealerUploadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealerUploadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DealerUpload.
     * @param {DealerUploadCreateArgs} args - Arguments to create a DealerUpload.
     * @example
     * // Create one DealerUpload
     * const DealerUpload = await prisma.dealerUpload.create({
     *   data: {
     *     // ... data to create a DealerUpload
     *   }
     * })
     * 
     */
    create<T extends DealerUploadCreateArgs>(args: SelectSubset<T, DealerUploadCreateArgs<ExtArgs>>): Prisma__DealerUploadClient<$Result.GetResult<Prisma.$DealerUploadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DealerUploads.
     * @param {DealerUploadCreateManyArgs} args - Arguments to create many DealerUploads.
     * @example
     * // Create many DealerUploads
     * const dealerUpload = await prisma.dealerUpload.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealerUploadCreateManyArgs>(args?: SelectSubset<T, DealerUploadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DealerUpload.
     * @param {DealerUploadDeleteArgs} args - Arguments to delete one DealerUpload.
     * @example
     * // Delete one DealerUpload
     * const DealerUpload = await prisma.dealerUpload.delete({
     *   where: {
     *     // ... filter to delete one DealerUpload
     *   }
     * })
     * 
     */
    delete<T extends DealerUploadDeleteArgs>(args: SelectSubset<T, DealerUploadDeleteArgs<ExtArgs>>): Prisma__DealerUploadClient<$Result.GetResult<Prisma.$DealerUploadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DealerUpload.
     * @param {DealerUploadUpdateArgs} args - Arguments to update one DealerUpload.
     * @example
     * // Update one DealerUpload
     * const dealerUpload = await prisma.dealerUpload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealerUploadUpdateArgs>(args: SelectSubset<T, DealerUploadUpdateArgs<ExtArgs>>): Prisma__DealerUploadClient<$Result.GetResult<Prisma.$DealerUploadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DealerUploads.
     * @param {DealerUploadDeleteManyArgs} args - Arguments to filter DealerUploads to delete.
     * @example
     * // Delete a few DealerUploads
     * const { count } = await prisma.dealerUpload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealerUploadDeleteManyArgs>(args?: SelectSubset<T, DealerUploadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DealerUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerUploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DealerUploads
     * const dealerUpload = await prisma.dealerUpload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealerUploadUpdateManyArgs>(args: SelectSubset<T, DealerUploadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DealerUpload.
     * @param {DealerUploadUpsertArgs} args - Arguments to update or create a DealerUpload.
     * @example
     * // Update or create a DealerUpload
     * const dealerUpload = await prisma.dealerUpload.upsert({
     *   create: {
     *     // ... data to create a DealerUpload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DealerUpload we want to update
     *   }
     * })
     */
    upsert<T extends DealerUploadUpsertArgs>(args: SelectSubset<T, DealerUploadUpsertArgs<ExtArgs>>): Prisma__DealerUploadClient<$Result.GetResult<Prisma.$DealerUploadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more DealerUploads that matches the filter.
     * @param {DealerUploadFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const dealerUpload = await prisma.dealerUpload.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: DealerUploadFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a DealerUpload.
     * @param {DealerUploadAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const dealerUpload = await prisma.dealerUpload.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: DealerUploadAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of DealerUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerUploadCountArgs} args - Arguments to filter DealerUploads to count.
     * @example
     * // Count the number of DealerUploads
     * const count = await prisma.dealerUpload.count({
     *   where: {
     *     // ... the filter for the DealerUploads we want to count
     *   }
     * })
    **/
    count<T extends DealerUploadCountArgs>(
      args?: Subset<T, DealerUploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealerUploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DealerUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerUploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealerUploadAggregateArgs>(args: Subset<T, DealerUploadAggregateArgs>): Prisma.PrismaPromise<GetDealerUploadAggregateType<T>>

    /**
     * Group by DealerUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealerUploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealerUploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealerUploadGroupByArgs['orderBy'] }
        : { orderBy?: DealerUploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealerUploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealerUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DealerUpload model
   */
  readonly fields: DealerUploadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DealerUpload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealerUploadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DealerUpload model
   */ 
  interface DealerUploadFieldRefs {
    readonly id: FieldRef<"DealerUpload", 'String'>
    readonly userId: FieldRef<"DealerUpload", 'String'>
    readonly email: FieldRef<"DealerUpload", 'String'>
    readonly name: FieldRef<"DealerUpload", 'String'>
    readonly category: FieldRef<"DealerUpload", 'String'>
    readonly description: FieldRef<"DealerUpload", 'String'>
    readonly status: FieldRef<"DealerUpload", 'DealerUploadStatus'>
    readonly reviewerId: FieldRef<"DealerUpload", 'String'>
    readonly reviewNote: FieldRef<"DealerUpload", 'String'>
    readonly createdAt: FieldRef<"DealerUpload", 'DateTime'>
    readonly reviewedAt: FieldRef<"DealerUpload", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DealerUpload findUnique
   */
  export type DealerUploadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealerUpload
     */
    select?: DealerUploadSelect<ExtArgs> | null
    /**
     * Filter, which DealerUpload to fetch.
     */
    where: DealerUploadWhereUniqueInput
  }

  /**
   * DealerUpload findUniqueOrThrow
   */
  export type DealerUploadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealerUpload
     */
    select?: DealerUploadSelect<ExtArgs> | null
    /**
     * Filter, which DealerUpload to fetch.
     */
    where: DealerUploadWhereUniqueInput
  }

  /**
   * DealerUpload findFirst
   */
  export type DealerUploadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealerUpload
     */
    select?: DealerUploadSelect<ExtArgs> | null
    /**
     * Filter, which DealerUpload to fetch.
     */
    where?: DealerUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealerUploads to fetch.
     */
    orderBy?: DealerUploadOrderByWithRelationInput | DealerUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealerUploads.
     */
    cursor?: DealerUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealerUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealerUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealerUploads.
     */
    distinct?: DealerUploadScalarFieldEnum | DealerUploadScalarFieldEnum[]
  }

  /**
   * DealerUpload findFirstOrThrow
   */
  export type DealerUploadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealerUpload
     */
    select?: DealerUploadSelect<ExtArgs> | null
    /**
     * Filter, which DealerUpload to fetch.
     */
    where?: DealerUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealerUploads to fetch.
     */
    orderBy?: DealerUploadOrderByWithRelationInput | DealerUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DealerUploads.
     */
    cursor?: DealerUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealerUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealerUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DealerUploads.
     */
    distinct?: DealerUploadScalarFieldEnum | DealerUploadScalarFieldEnum[]
  }

  /**
   * DealerUpload findMany
   */
  export type DealerUploadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealerUpload
     */
    select?: DealerUploadSelect<ExtArgs> | null
    /**
     * Filter, which DealerUploads to fetch.
     */
    where?: DealerUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DealerUploads to fetch.
     */
    orderBy?: DealerUploadOrderByWithRelationInput | DealerUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DealerUploads.
     */
    cursor?: DealerUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DealerUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DealerUploads.
     */
    skip?: number
    distinct?: DealerUploadScalarFieldEnum | DealerUploadScalarFieldEnum[]
  }

  /**
   * DealerUpload create
   */
  export type DealerUploadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealerUpload
     */
    select?: DealerUploadSelect<ExtArgs> | null
    /**
     * The data needed to create a DealerUpload.
     */
    data: XOR<DealerUploadCreateInput, DealerUploadUncheckedCreateInput>
  }

  /**
   * DealerUpload createMany
   */
  export type DealerUploadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DealerUploads.
     */
    data: DealerUploadCreateManyInput | DealerUploadCreateManyInput[]
  }

  /**
   * DealerUpload update
   */
  export type DealerUploadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealerUpload
     */
    select?: DealerUploadSelect<ExtArgs> | null
    /**
     * The data needed to update a DealerUpload.
     */
    data: XOR<DealerUploadUpdateInput, DealerUploadUncheckedUpdateInput>
    /**
     * Choose, which DealerUpload to update.
     */
    where: DealerUploadWhereUniqueInput
  }

  /**
   * DealerUpload updateMany
   */
  export type DealerUploadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DealerUploads.
     */
    data: XOR<DealerUploadUpdateManyMutationInput, DealerUploadUncheckedUpdateManyInput>
    /**
     * Filter which DealerUploads to update
     */
    where?: DealerUploadWhereInput
  }

  /**
   * DealerUpload upsert
   */
  export type DealerUploadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealerUpload
     */
    select?: DealerUploadSelect<ExtArgs> | null
    /**
     * The filter to search for the DealerUpload to update in case it exists.
     */
    where: DealerUploadWhereUniqueInput
    /**
     * In case the DealerUpload found by the `where` argument doesn't exist, create a new DealerUpload with this data.
     */
    create: XOR<DealerUploadCreateInput, DealerUploadUncheckedCreateInput>
    /**
     * In case the DealerUpload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealerUploadUpdateInput, DealerUploadUncheckedUpdateInput>
  }

  /**
   * DealerUpload delete
   */
  export type DealerUploadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealerUpload
     */
    select?: DealerUploadSelect<ExtArgs> | null
    /**
     * Filter which DealerUpload to delete.
     */
    where: DealerUploadWhereUniqueInput
  }

  /**
   * DealerUpload deleteMany
   */
  export type DealerUploadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DealerUploads to delete
     */
    where?: DealerUploadWhereInput
  }

  /**
   * DealerUpload findRaw
   */
  export type DealerUploadFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DealerUpload aggregateRaw
   */
  export type DealerUploadAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * DealerUpload without action
   */
  export type DealerUploadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealerUpload
     */
    select?: DealerUploadSelect<ExtArgs> | null
  }


  /**
   * Model TrainingEvent
   */

  export type AggregateTrainingEvent = {
    _count: TrainingEventCountAggregateOutputType | null
    _min: TrainingEventMinAggregateOutputType | null
    _max: TrainingEventMaxAggregateOutputType | null
  }

  export type TrainingEventMinAggregateOutputType = {
    id: string | null
    title: string | null
    datetime: Date | null
    mode: $Enums.TrainingMode | null
    location: string | null
    desc: string | null
    status: $Enums.TrainingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingEventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    datetime: Date | null
    mode: $Enums.TrainingMode | null
    location: string | null
    desc: string | null
    status: $Enums.TrainingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingEventCountAggregateOutputType = {
    id: number
    title: number
    datetime: number
    mode: number
    location: number
    desc: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingEventMinAggregateInputType = {
    id?: true
    title?: true
    datetime?: true
    mode?: true
    location?: true
    desc?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingEventMaxAggregateInputType = {
    id?: true
    title?: true
    datetime?: true
    mode?: true
    location?: true
    desc?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingEventCountAggregateInputType = {
    id?: true
    title?: true
    datetime?: true
    mode?: true
    location?: true
    desc?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingEvent to aggregate.
     */
    where?: TrainingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEvents to fetch.
     */
    orderBy?: TrainingEventOrderByWithRelationInput | TrainingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingEvents
    **/
    _count?: true | TrainingEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingEventMaxAggregateInputType
  }

  export type GetTrainingEventAggregateType<T extends TrainingEventAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingEvent[P]>
      : GetScalarType<T[P], AggregateTrainingEvent[P]>
  }




  export type TrainingEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingEventWhereInput
    orderBy?: TrainingEventOrderByWithAggregationInput | TrainingEventOrderByWithAggregationInput[]
    by: TrainingEventScalarFieldEnum[] | TrainingEventScalarFieldEnum
    having?: TrainingEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingEventCountAggregateInputType | true
    _min?: TrainingEventMinAggregateInputType
    _max?: TrainingEventMaxAggregateInputType
  }

  export type TrainingEventGroupByOutputType = {
    id: string
    title: string
    datetime: Date
    mode: $Enums.TrainingMode
    location: string | null
    desc: string | null
    status: $Enums.TrainingStatus
    createdAt: Date
    updatedAt: Date
    _count: TrainingEventCountAggregateOutputType | null
    _min: TrainingEventMinAggregateOutputType | null
    _max: TrainingEventMaxAggregateOutputType | null
  }

  type GetTrainingEventGroupByPayload<T extends TrainingEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingEventGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingEventGroupByOutputType[P]>
        }
      >
    >


  export type TrainingEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    datetime?: boolean
    mode?: boolean
    location?: boolean
    desc?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["trainingEvent"]>


  export type TrainingEventSelectScalar = {
    id?: boolean
    title?: boolean
    datetime?: boolean
    mode?: boolean
    location?: boolean
    desc?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $TrainingEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingEvent"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      datetime: Date
      mode: $Enums.TrainingMode
      location: string | null
      desc: string | null
      status: $Enums.TrainingStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingEvent"]>
    composites: {}
  }

  type TrainingEventGetPayload<S extends boolean | null | undefined | TrainingEventDefaultArgs> = $Result.GetResult<Prisma.$TrainingEventPayload, S>

  type TrainingEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingEventCountAggregateInputType | true
    }

  export interface TrainingEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingEvent'], meta: { name: 'TrainingEvent' } }
    /**
     * Find zero or one TrainingEvent that matches the filter.
     * @param {TrainingEventFindUniqueArgs} args - Arguments to find a TrainingEvent
     * @example
     * // Get one TrainingEvent
     * const trainingEvent = await prisma.trainingEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingEventFindUniqueArgs>(args: SelectSubset<T, TrainingEventFindUniqueArgs<ExtArgs>>): Prisma__TrainingEventClient<$Result.GetResult<Prisma.$TrainingEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainingEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingEventFindUniqueOrThrowArgs} args - Arguments to find a TrainingEvent
     * @example
     * // Get one TrainingEvent
     * const trainingEvent = await prisma.trainingEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingEventFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingEventClient<$Result.GetResult<Prisma.$TrainingEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainingEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEventFindFirstArgs} args - Arguments to find a TrainingEvent
     * @example
     * // Get one TrainingEvent
     * const trainingEvent = await prisma.trainingEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingEventFindFirstArgs>(args?: SelectSubset<T, TrainingEventFindFirstArgs<ExtArgs>>): Prisma__TrainingEventClient<$Result.GetResult<Prisma.$TrainingEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainingEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEventFindFirstOrThrowArgs} args - Arguments to find a TrainingEvent
     * @example
     * // Get one TrainingEvent
     * const trainingEvent = await prisma.trainingEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingEventFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingEventClient<$Result.GetResult<Prisma.$TrainingEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainingEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingEvents
     * const trainingEvents = await prisma.trainingEvent.findMany()
     * 
     * // Get first 10 TrainingEvents
     * const trainingEvents = await prisma.trainingEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingEventWithIdOnly = await prisma.trainingEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingEventFindManyArgs>(args?: SelectSubset<T, TrainingEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainingEvent.
     * @param {TrainingEventCreateArgs} args - Arguments to create a TrainingEvent.
     * @example
     * // Create one TrainingEvent
     * const TrainingEvent = await prisma.trainingEvent.create({
     *   data: {
     *     // ... data to create a TrainingEvent
     *   }
     * })
     * 
     */
    create<T extends TrainingEventCreateArgs>(args: SelectSubset<T, TrainingEventCreateArgs<ExtArgs>>): Prisma__TrainingEventClient<$Result.GetResult<Prisma.$TrainingEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainingEvents.
     * @param {TrainingEventCreateManyArgs} args - Arguments to create many TrainingEvents.
     * @example
     * // Create many TrainingEvents
     * const trainingEvent = await prisma.trainingEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingEventCreateManyArgs>(args?: SelectSubset<T, TrainingEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrainingEvent.
     * @param {TrainingEventDeleteArgs} args - Arguments to delete one TrainingEvent.
     * @example
     * // Delete one TrainingEvent
     * const TrainingEvent = await prisma.trainingEvent.delete({
     *   where: {
     *     // ... filter to delete one TrainingEvent
     *   }
     * })
     * 
     */
    delete<T extends TrainingEventDeleteArgs>(args: SelectSubset<T, TrainingEventDeleteArgs<ExtArgs>>): Prisma__TrainingEventClient<$Result.GetResult<Prisma.$TrainingEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainingEvent.
     * @param {TrainingEventUpdateArgs} args - Arguments to update one TrainingEvent.
     * @example
     * // Update one TrainingEvent
     * const trainingEvent = await prisma.trainingEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingEventUpdateArgs>(args: SelectSubset<T, TrainingEventUpdateArgs<ExtArgs>>): Prisma__TrainingEventClient<$Result.GetResult<Prisma.$TrainingEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainingEvents.
     * @param {TrainingEventDeleteManyArgs} args - Arguments to filter TrainingEvents to delete.
     * @example
     * // Delete a few TrainingEvents
     * const { count } = await prisma.trainingEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingEventDeleteManyArgs>(args?: SelectSubset<T, TrainingEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingEvents
     * const trainingEvent = await prisma.trainingEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingEventUpdateManyArgs>(args: SelectSubset<T, TrainingEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingEvent.
     * @param {TrainingEventUpsertArgs} args - Arguments to update or create a TrainingEvent.
     * @example
     * // Update or create a TrainingEvent
     * const trainingEvent = await prisma.trainingEvent.upsert({
     *   create: {
     *     // ... data to create a TrainingEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingEvent we want to update
     *   }
     * })
     */
    upsert<T extends TrainingEventUpsertArgs>(args: SelectSubset<T, TrainingEventUpsertArgs<ExtArgs>>): Prisma__TrainingEventClient<$Result.GetResult<Prisma.$TrainingEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more TrainingEvents that matches the filter.
     * @param {TrainingEventFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const trainingEvent = await prisma.trainingEvent.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TrainingEventFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TrainingEvent.
     * @param {TrainingEventAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const trainingEvent = await prisma.trainingEvent.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TrainingEventAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TrainingEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEventCountArgs} args - Arguments to filter TrainingEvents to count.
     * @example
     * // Count the number of TrainingEvents
     * const count = await prisma.trainingEvent.count({
     *   where: {
     *     // ... the filter for the TrainingEvents we want to count
     *   }
     * })
    **/
    count<T extends TrainingEventCountArgs>(
      args?: Subset<T, TrainingEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingEventAggregateArgs>(args: Subset<T, TrainingEventAggregateArgs>): Prisma.PrismaPromise<GetTrainingEventAggregateType<T>>

    /**
     * Group by TrainingEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingEventGroupByArgs['orderBy'] }
        : { orderBy?: TrainingEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingEvent model
   */
  readonly fields: TrainingEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingEvent model
   */ 
  interface TrainingEventFieldRefs {
    readonly id: FieldRef<"TrainingEvent", 'String'>
    readonly title: FieldRef<"TrainingEvent", 'String'>
    readonly datetime: FieldRef<"TrainingEvent", 'DateTime'>
    readonly mode: FieldRef<"TrainingEvent", 'TrainingMode'>
    readonly location: FieldRef<"TrainingEvent", 'String'>
    readonly desc: FieldRef<"TrainingEvent", 'String'>
    readonly status: FieldRef<"TrainingEvent", 'TrainingStatus'>
    readonly createdAt: FieldRef<"TrainingEvent", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingEvent findUnique
   */
  export type TrainingEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvent
     */
    select?: TrainingEventSelect<ExtArgs> | null
    /**
     * Filter, which TrainingEvent to fetch.
     */
    where: TrainingEventWhereUniqueInput
  }

  /**
   * TrainingEvent findUniqueOrThrow
   */
  export type TrainingEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvent
     */
    select?: TrainingEventSelect<ExtArgs> | null
    /**
     * Filter, which TrainingEvent to fetch.
     */
    where: TrainingEventWhereUniqueInput
  }

  /**
   * TrainingEvent findFirst
   */
  export type TrainingEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvent
     */
    select?: TrainingEventSelect<ExtArgs> | null
    /**
     * Filter, which TrainingEvent to fetch.
     */
    where?: TrainingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEvents to fetch.
     */
    orderBy?: TrainingEventOrderByWithRelationInput | TrainingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingEvents.
     */
    cursor?: TrainingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingEvents.
     */
    distinct?: TrainingEventScalarFieldEnum | TrainingEventScalarFieldEnum[]
  }

  /**
   * TrainingEvent findFirstOrThrow
   */
  export type TrainingEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvent
     */
    select?: TrainingEventSelect<ExtArgs> | null
    /**
     * Filter, which TrainingEvent to fetch.
     */
    where?: TrainingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEvents to fetch.
     */
    orderBy?: TrainingEventOrderByWithRelationInput | TrainingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingEvents.
     */
    cursor?: TrainingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingEvents.
     */
    distinct?: TrainingEventScalarFieldEnum | TrainingEventScalarFieldEnum[]
  }

  /**
   * TrainingEvent findMany
   */
  export type TrainingEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvent
     */
    select?: TrainingEventSelect<ExtArgs> | null
    /**
     * Filter, which TrainingEvents to fetch.
     */
    where?: TrainingEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingEvents to fetch.
     */
    orderBy?: TrainingEventOrderByWithRelationInput | TrainingEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingEvents.
     */
    cursor?: TrainingEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingEvents.
     */
    skip?: number
    distinct?: TrainingEventScalarFieldEnum | TrainingEventScalarFieldEnum[]
  }

  /**
   * TrainingEvent create
   */
  export type TrainingEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvent
     */
    select?: TrainingEventSelect<ExtArgs> | null
    /**
     * The data needed to create a TrainingEvent.
     */
    data: XOR<TrainingEventCreateInput, TrainingEventUncheckedCreateInput>
  }

  /**
   * TrainingEvent createMany
   */
  export type TrainingEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingEvents.
     */
    data: TrainingEventCreateManyInput | TrainingEventCreateManyInput[]
  }

  /**
   * TrainingEvent update
   */
  export type TrainingEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvent
     */
    select?: TrainingEventSelect<ExtArgs> | null
    /**
     * The data needed to update a TrainingEvent.
     */
    data: XOR<TrainingEventUpdateInput, TrainingEventUncheckedUpdateInput>
    /**
     * Choose, which TrainingEvent to update.
     */
    where: TrainingEventWhereUniqueInput
  }

  /**
   * TrainingEvent updateMany
   */
  export type TrainingEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingEvents.
     */
    data: XOR<TrainingEventUpdateManyMutationInput, TrainingEventUncheckedUpdateManyInput>
    /**
     * Filter which TrainingEvents to update
     */
    where?: TrainingEventWhereInput
  }

  /**
   * TrainingEvent upsert
   */
  export type TrainingEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvent
     */
    select?: TrainingEventSelect<ExtArgs> | null
    /**
     * The filter to search for the TrainingEvent to update in case it exists.
     */
    where: TrainingEventWhereUniqueInput
    /**
     * In case the TrainingEvent found by the `where` argument doesn't exist, create a new TrainingEvent with this data.
     */
    create: XOR<TrainingEventCreateInput, TrainingEventUncheckedCreateInput>
    /**
     * In case the TrainingEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingEventUpdateInput, TrainingEventUncheckedUpdateInput>
  }

  /**
   * TrainingEvent delete
   */
  export type TrainingEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvent
     */
    select?: TrainingEventSelect<ExtArgs> | null
    /**
     * Filter which TrainingEvent to delete.
     */
    where: TrainingEventWhereUniqueInput
  }

  /**
   * TrainingEvent deleteMany
   */
  export type TrainingEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingEvents to delete
     */
    where?: TrainingEventWhereInput
  }

  /**
   * TrainingEvent findRaw
   */
  export type TrainingEventFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TrainingEvent aggregateRaw
   */
  export type TrainingEventAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TrainingEvent without action
   */
  export type TrainingEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingEvent
     */
    select?: TrainingEventSelect<ExtArgs> | null
  }


  /**
   * Model TrainingRegistration
   */

  export type AggregateTrainingRegistration = {
    _count: TrainingRegistrationCountAggregateOutputType | null
    _min: TrainingRegistrationMinAggregateOutputType | null
    _max: TrainingRegistrationMaxAggregateOutputType | null
  }

  export type TrainingRegistrationMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    note: string | null
    status: string | null
    createdAt: Date | null
  }

  export type TrainingRegistrationMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    note: string | null
    status: string | null
    createdAt: Date | null
  }

  export type TrainingRegistrationCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    note: number
    status: number
    createdAt: number
    _all: number
  }


  export type TrainingRegistrationMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    note?: true
    status?: true
    createdAt?: true
  }

  export type TrainingRegistrationMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    note?: true
    status?: true
    createdAt?: true
  }

  export type TrainingRegistrationCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    note?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type TrainingRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingRegistration to aggregate.
     */
    where?: TrainingRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingRegistrations to fetch.
     */
    orderBy?: TrainingRegistrationOrderByWithRelationInput | TrainingRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingRegistrations
    **/
    _count?: true | TrainingRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingRegistrationMaxAggregateInputType
  }

  export type GetTrainingRegistrationAggregateType<T extends TrainingRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingRegistration[P]>
      : GetScalarType<T[P], AggregateTrainingRegistration[P]>
  }




  export type TrainingRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingRegistrationWhereInput
    orderBy?: TrainingRegistrationOrderByWithAggregationInput | TrainingRegistrationOrderByWithAggregationInput[]
    by: TrainingRegistrationScalarFieldEnum[] | TrainingRegistrationScalarFieldEnum
    having?: TrainingRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingRegistrationCountAggregateInputType | true
    _min?: TrainingRegistrationMinAggregateInputType
    _max?: TrainingRegistrationMaxAggregateInputType
  }

  export type TrainingRegistrationGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    note: string | null
    status: string
    createdAt: Date
    _count: TrainingRegistrationCountAggregateOutputType | null
    _min: TrainingRegistrationMinAggregateOutputType | null
    _max: TrainingRegistrationMaxAggregateOutputType | null
  }

  type GetTrainingRegistrationGroupByPayload<T extends TrainingRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type TrainingRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    note?: boolean
    status?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["trainingRegistration"]>


  export type TrainingRegistrationSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    note?: boolean
    status?: boolean
    createdAt?: boolean
  }


  export type $TrainingRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingRegistration"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      note: string | null
      status: string
      createdAt: Date
    }, ExtArgs["result"]["trainingRegistration"]>
    composites: {}
  }

  type TrainingRegistrationGetPayload<S extends boolean | null | undefined | TrainingRegistrationDefaultArgs> = $Result.GetResult<Prisma.$TrainingRegistrationPayload, S>

  type TrainingRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingRegistrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingRegistrationCountAggregateInputType | true
    }

  export interface TrainingRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingRegistration'], meta: { name: 'TrainingRegistration' } }
    /**
     * Find zero or one TrainingRegistration that matches the filter.
     * @param {TrainingRegistrationFindUniqueArgs} args - Arguments to find a TrainingRegistration
     * @example
     * // Get one TrainingRegistration
     * const trainingRegistration = await prisma.trainingRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingRegistrationFindUniqueArgs>(args: SelectSubset<T, TrainingRegistrationFindUniqueArgs<ExtArgs>>): Prisma__TrainingRegistrationClient<$Result.GetResult<Prisma.$TrainingRegistrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainingRegistration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingRegistrationFindUniqueOrThrowArgs} args - Arguments to find a TrainingRegistration
     * @example
     * // Get one TrainingRegistration
     * const trainingRegistration = await prisma.trainingRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingRegistrationClient<$Result.GetResult<Prisma.$TrainingRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainingRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRegistrationFindFirstArgs} args - Arguments to find a TrainingRegistration
     * @example
     * // Get one TrainingRegistration
     * const trainingRegistration = await prisma.trainingRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingRegistrationFindFirstArgs>(args?: SelectSubset<T, TrainingRegistrationFindFirstArgs<ExtArgs>>): Prisma__TrainingRegistrationClient<$Result.GetResult<Prisma.$TrainingRegistrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainingRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRegistrationFindFirstOrThrowArgs} args - Arguments to find a TrainingRegistration
     * @example
     * // Get one TrainingRegistration
     * const trainingRegistration = await prisma.trainingRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingRegistrationClient<$Result.GetResult<Prisma.$TrainingRegistrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainingRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingRegistrations
     * const trainingRegistrations = await prisma.trainingRegistration.findMany()
     * 
     * // Get first 10 TrainingRegistrations
     * const trainingRegistrations = await prisma.trainingRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingRegistrationWithIdOnly = await prisma.trainingRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingRegistrationFindManyArgs>(args?: SelectSubset<T, TrainingRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingRegistrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainingRegistration.
     * @param {TrainingRegistrationCreateArgs} args - Arguments to create a TrainingRegistration.
     * @example
     * // Create one TrainingRegistration
     * const TrainingRegistration = await prisma.trainingRegistration.create({
     *   data: {
     *     // ... data to create a TrainingRegistration
     *   }
     * })
     * 
     */
    create<T extends TrainingRegistrationCreateArgs>(args: SelectSubset<T, TrainingRegistrationCreateArgs<ExtArgs>>): Prisma__TrainingRegistrationClient<$Result.GetResult<Prisma.$TrainingRegistrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainingRegistrations.
     * @param {TrainingRegistrationCreateManyArgs} args - Arguments to create many TrainingRegistrations.
     * @example
     * // Create many TrainingRegistrations
     * const trainingRegistration = await prisma.trainingRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingRegistrationCreateManyArgs>(args?: SelectSubset<T, TrainingRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TrainingRegistration.
     * @param {TrainingRegistrationDeleteArgs} args - Arguments to delete one TrainingRegistration.
     * @example
     * // Delete one TrainingRegistration
     * const TrainingRegistration = await prisma.trainingRegistration.delete({
     *   where: {
     *     // ... filter to delete one TrainingRegistration
     *   }
     * })
     * 
     */
    delete<T extends TrainingRegistrationDeleteArgs>(args: SelectSubset<T, TrainingRegistrationDeleteArgs<ExtArgs>>): Prisma__TrainingRegistrationClient<$Result.GetResult<Prisma.$TrainingRegistrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainingRegistration.
     * @param {TrainingRegistrationUpdateArgs} args - Arguments to update one TrainingRegistration.
     * @example
     * // Update one TrainingRegistration
     * const trainingRegistration = await prisma.trainingRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingRegistrationUpdateArgs>(args: SelectSubset<T, TrainingRegistrationUpdateArgs<ExtArgs>>): Prisma__TrainingRegistrationClient<$Result.GetResult<Prisma.$TrainingRegistrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainingRegistrations.
     * @param {TrainingRegistrationDeleteManyArgs} args - Arguments to filter TrainingRegistrations to delete.
     * @example
     * // Delete a few TrainingRegistrations
     * const { count } = await prisma.trainingRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingRegistrationDeleteManyArgs>(args?: SelectSubset<T, TrainingRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingRegistrations
     * const trainingRegistration = await prisma.trainingRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingRegistrationUpdateManyArgs>(args: SelectSubset<T, TrainingRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingRegistration.
     * @param {TrainingRegistrationUpsertArgs} args - Arguments to update or create a TrainingRegistration.
     * @example
     * // Update or create a TrainingRegistration
     * const trainingRegistration = await prisma.trainingRegistration.upsert({
     *   create: {
     *     // ... data to create a TrainingRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingRegistration we want to update
     *   }
     * })
     */
    upsert<T extends TrainingRegistrationUpsertArgs>(args: SelectSubset<T, TrainingRegistrationUpsertArgs<ExtArgs>>): Prisma__TrainingRegistrationClient<$Result.GetResult<Prisma.$TrainingRegistrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more TrainingRegistrations that matches the filter.
     * @param {TrainingRegistrationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const trainingRegistration = await prisma.trainingRegistration.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: TrainingRegistrationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a TrainingRegistration.
     * @param {TrainingRegistrationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const trainingRegistration = await prisma.trainingRegistration.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TrainingRegistrationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of TrainingRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRegistrationCountArgs} args - Arguments to filter TrainingRegistrations to count.
     * @example
     * // Count the number of TrainingRegistrations
     * const count = await prisma.trainingRegistration.count({
     *   where: {
     *     // ... the filter for the TrainingRegistrations we want to count
     *   }
     * })
    **/
    count<T extends TrainingRegistrationCountArgs>(
      args?: Subset<T, TrainingRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingRegistrationAggregateArgs>(args: Subset<T, TrainingRegistrationAggregateArgs>): Prisma.PrismaPromise<GetTrainingRegistrationAggregateType<T>>

    /**
     * Group by TrainingRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: TrainingRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingRegistration model
   */
  readonly fields: TrainingRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingRegistration model
   */ 
  interface TrainingRegistrationFieldRefs {
    readonly id: FieldRef<"TrainingRegistration", 'String'>
    readonly eventId: FieldRef<"TrainingRegistration", 'String'>
    readonly userId: FieldRef<"TrainingRegistration", 'String'>
    readonly note: FieldRef<"TrainingRegistration", 'String'>
    readonly status: FieldRef<"TrainingRegistration", 'String'>
    readonly createdAt: FieldRef<"TrainingRegistration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingRegistration findUnique
   */
  export type TrainingRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRegistration
     */
    select?: TrainingRegistrationSelect<ExtArgs> | null
    /**
     * Filter, which TrainingRegistration to fetch.
     */
    where: TrainingRegistrationWhereUniqueInput
  }

  /**
   * TrainingRegistration findUniqueOrThrow
   */
  export type TrainingRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRegistration
     */
    select?: TrainingRegistrationSelect<ExtArgs> | null
    /**
     * Filter, which TrainingRegistration to fetch.
     */
    where: TrainingRegistrationWhereUniqueInput
  }

  /**
   * TrainingRegistration findFirst
   */
  export type TrainingRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRegistration
     */
    select?: TrainingRegistrationSelect<ExtArgs> | null
    /**
     * Filter, which TrainingRegistration to fetch.
     */
    where?: TrainingRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingRegistrations to fetch.
     */
    orderBy?: TrainingRegistrationOrderByWithRelationInput | TrainingRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingRegistrations.
     */
    cursor?: TrainingRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingRegistrations.
     */
    distinct?: TrainingRegistrationScalarFieldEnum | TrainingRegistrationScalarFieldEnum[]
  }

  /**
   * TrainingRegistration findFirstOrThrow
   */
  export type TrainingRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRegistration
     */
    select?: TrainingRegistrationSelect<ExtArgs> | null
    /**
     * Filter, which TrainingRegistration to fetch.
     */
    where?: TrainingRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingRegistrations to fetch.
     */
    orderBy?: TrainingRegistrationOrderByWithRelationInput | TrainingRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingRegistrations.
     */
    cursor?: TrainingRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingRegistrations.
     */
    distinct?: TrainingRegistrationScalarFieldEnum | TrainingRegistrationScalarFieldEnum[]
  }

  /**
   * TrainingRegistration findMany
   */
  export type TrainingRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRegistration
     */
    select?: TrainingRegistrationSelect<ExtArgs> | null
    /**
     * Filter, which TrainingRegistrations to fetch.
     */
    where?: TrainingRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingRegistrations to fetch.
     */
    orderBy?: TrainingRegistrationOrderByWithRelationInput | TrainingRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingRegistrations.
     */
    cursor?: TrainingRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingRegistrations.
     */
    skip?: number
    distinct?: TrainingRegistrationScalarFieldEnum | TrainingRegistrationScalarFieldEnum[]
  }

  /**
   * TrainingRegistration create
   */
  export type TrainingRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRegistration
     */
    select?: TrainingRegistrationSelect<ExtArgs> | null
    /**
     * The data needed to create a TrainingRegistration.
     */
    data: XOR<TrainingRegistrationCreateInput, TrainingRegistrationUncheckedCreateInput>
  }

  /**
   * TrainingRegistration createMany
   */
  export type TrainingRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingRegistrations.
     */
    data: TrainingRegistrationCreateManyInput | TrainingRegistrationCreateManyInput[]
  }

  /**
   * TrainingRegistration update
   */
  export type TrainingRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRegistration
     */
    select?: TrainingRegistrationSelect<ExtArgs> | null
    /**
     * The data needed to update a TrainingRegistration.
     */
    data: XOR<TrainingRegistrationUpdateInput, TrainingRegistrationUncheckedUpdateInput>
    /**
     * Choose, which TrainingRegistration to update.
     */
    where: TrainingRegistrationWhereUniqueInput
  }

  /**
   * TrainingRegistration updateMany
   */
  export type TrainingRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingRegistrations.
     */
    data: XOR<TrainingRegistrationUpdateManyMutationInput, TrainingRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which TrainingRegistrations to update
     */
    where?: TrainingRegistrationWhereInput
  }

  /**
   * TrainingRegistration upsert
   */
  export type TrainingRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRegistration
     */
    select?: TrainingRegistrationSelect<ExtArgs> | null
    /**
     * The filter to search for the TrainingRegistration to update in case it exists.
     */
    where: TrainingRegistrationWhereUniqueInput
    /**
     * In case the TrainingRegistration found by the `where` argument doesn't exist, create a new TrainingRegistration with this data.
     */
    create: XOR<TrainingRegistrationCreateInput, TrainingRegistrationUncheckedCreateInput>
    /**
     * In case the TrainingRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingRegistrationUpdateInput, TrainingRegistrationUncheckedUpdateInput>
  }

  /**
   * TrainingRegistration delete
   */
  export type TrainingRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRegistration
     */
    select?: TrainingRegistrationSelect<ExtArgs> | null
    /**
     * Filter which TrainingRegistration to delete.
     */
    where: TrainingRegistrationWhereUniqueInput
  }

  /**
   * TrainingRegistration deleteMany
   */
  export type TrainingRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingRegistrations to delete
     */
    where?: TrainingRegistrationWhereInput
  }

  /**
   * TrainingRegistration findRaw
   */
  export type TrainingRegistrationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TrainingRegistration aggregateRaw
   */
  export type TrainingRegistrationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * TrainingRegistration without action
   */
  export type TrainingRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingRegistration
     */
    select?: TrainingRegistrationSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    displayName: 'displayName',
    roles: 'roles',
    profile: 'profile',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    refreshToken: 'refreshToken',
    userAgent: 'userAgent',
    ip: 'ip',
    createdAt: 'createdAt',
    revokedAt: 'revokedAt'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const PageScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    body: 'body',
    status: 'status',
    meta: 'meta',
    createdById: 'createdById',
    updatedById: 'updatedById',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


  export const UploadAssetScalarFieldEnum: {
    id: 'id',
    objectKey: 'objectKey',
    contentType: 'contentType',
    size: 'size',
    publicUrl: 'publicUrl',
    context: 'context',
    uploaderId: 'uploaderId',
    createdAt: 'createdAt'
  };

  export type UploadAssetScalarFieldEnum = (typeof UploadAssetScalarFieldEnum)[keyof typeof UploadAssetScalarFieldEnum]


  export const InstallationScalarFieldEnum: {
    id: 'id',
    dealerId: 'dealerId',
    siteName: 'siteName',
    address: 'address',
    customerInfo: 'customerInfo',
    scheduledAt: 'scheduledAt',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstallationScalarFieldEnum = (typeof InstallationScalarFieldEnum)[keyof typeof InstallationScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    installationId: 'installationId',
    reportType: 'reportType',
    notes: 'notes',
    uploadObjectKey: 'uploadObjectKey',
    createdAt: 'createdAt'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const AuditEventScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    action: 'action',
    target: 'target',
    meta: 'meta',
    createdAt: 'createdAt'
  };

  export type AuditEventScalarFieldEnum = (typeof AuditEventScalarFieldEnum)[keyof typeof AuditEventScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    company: 'company',
    country: 'country',
    type: 'type',
    message: 'message',
    tags: 'tags',
    status: 'status',
    owner: 'owner',
    createdAt: 'createdAt'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const DealerScalarFieldEnum: {
    id: 'id',
    org: 'org',
    contactName: 'contactName',
    contactEmail: 'contactEmail',
    region: 'region',
    status: 'status',
    users: 'users',
    last: 'last',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DealerScalarFieldEnum = (typeof DealerScalarFieldEnum)[keyof typeof DealerScalarFieldEnum]


  export const FileAssetScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    cat: 'cat',
    vis: 'vis',
    url: 'url',
    desc: 'desc',
    size: 'size',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FileAssetScalarFieldEnum = (typeof FileAssetScalarFieldEnum)[keyof typeof FileAssetScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    code: 'code',
    variant: 'variant',
    short: 'short',
    long: 'long',
    bullets: 'bullets',
    nij: 'nij',
    thickness: 'thickness',
    vlt: 'vlt',
    impact: 'impact',
    images: 'images',
    datasheet: 'datasheet',
    slug: 'slug',
    metaTitle: 'metaTitle',
    metaDesc: 'metaDesc',
    status: 'status',
    updatedAt: 'updatedAt',
    createdAt: 'createdAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const DealerUploadScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    name: 'name',
    category: 'category',
    description: 'description',
    status: 'status',
    reviewerId: 'reviewerId',
    reviewNote: 'reviewNote',
    createdAt: 'createdAt',
    reviewedAt: 'reviewedAt'
  };

  export type DealerUploadScalarFieldEnum = (typeof DealerUploadScalarFieldEnum)[keyof typeof DealerUploadScalarFieldEnum]


  export const TrainingEventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    datetime: 'datetime',
    mode: 'mode',
    location: 'location',
    desc: 'desc',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingEventScalarFieldEnum = (typeof TrainingEventScalarFieldEnum)[keyof typeof TrainingEventScalarFieldEnum]


  export const TrainingRegistrationScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    note: 'note',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type TrainingRegistrationScalarFieldEnum = (typeof TrainingRegistrationScalarFieldEnum)[keyof typeof TrainingRegistrationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PageStatus'
   */
  export type EnumPageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PageStatus'>
    


  /**
   * Reference to a field of type 'PageStatus[]'
   */
  export type ListEnumPageStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PageStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'InstallStatus'
   */
  export type EnumInstallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstallStatus'>
    


  /**
   * Reference to a field of type 'InstallStatus[]'
   */
  export type ListEnumInstallStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InstallStatus[]'>
    


  /**
   * Reference to a field of type 'LeadType'
   */
  export type EnumLeadTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadType'>
    


  /**
   * Reference to a field of type 'LeadType[]'
   */
  export type ListEnumLeadTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadType[]'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'DealerStatus'
   */
  export type EnumDealerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealerStatus'>
    


  /**
   * Reference to a field of type 'DealerStatus[]'
   */
  export type ListEnumDealerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealerStatus[]'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'FileCategory'
   */
  export type EnumFileCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileCategory'>
    


  /**
   * Reference to a field of type 'FileCategory[]'
   */
  export type ListEnumFileCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileCategory[]'>
    


  /**
   * Reference to a field of type 'FileVisibility'
   */
  export type EnumFileVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileVisibility'>
    


  /**
   * Reference to a field of type 'FileVisibility[]'
   */
  export type ListEnumFileVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileVisibility[]'>
    


  /**
   * Reference to a field of type 'ProductStatus'
   */
  export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus'>
    


  /**
   * Reference to a field of type 'ProductStatus[]'
   */
  export type ListEnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus[]'>
    


  /**
   * Reference to a field of type 'DealerUploadStatus'
   */
  export type EnumDealerUploadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealerUploadStatus'>
    


  /**
   * Reference to a field of type 'DealerUploadStatus[]'
   */
  export type ListEnumDealerUploadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DealerUploadStatus[]'>
    


  /**
   * Reference to a field of type 'TrainingMode'
   */
  export type EnumTrainingModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingMode'>
    


  /**
   * Reference to a field of type 'TrainingMode[]'
   */
  export type ListEnumTrainingModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingMode[]'>
    


  /**
   * Reference to a field of type 'TrainingStatus'
   */
  export type EnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus'>
    


  /**
   * Reference to a field of type 'TrainingStatus[]'
   */
  export type ListEnumTrainingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    displayName?: StringFilter<"User"> | string
    roles?: EnumRoleNullableListFilter<"User">
    profile?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    sessions?: SessionListRelationFilter
    uploads?: UploadAssetListRelationFilter
    pagesCreated?: PageListRelationFilter
    pagesUpdated?: PageListRelationFilter
    auditEvents?: AuditEventListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    roles?: SortOrder
    profile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    sessions?: SessionOrderByRelationAggregateInput
    uploads?: UploadAssetOrderByRelationAggregateInput
    pagesCreated?: PageOrderByRelationAggregateInput
    pagesUpdated?: PageOrderByRelationAggregateInput
    auditEvents?: AuditEventOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    displayName?: StringFilter<"User"> | string
    roles?: EnumRoleNullableListFilter<"User">
    profile?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    sessions?: SessionListRelationFilter
    uploads?: UploadAssetListRelationFilter
    pagesCreated?: PageListRelationFilter
    pagesUpdated?: PageListRelationFilter
    auditEvents?: AuditEventListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    roles?: SortOrder
    profile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    displayName?: StringWithAggregatesFilter<"User"> | string
    roles?: EnumRoleNullableListFilter<"User">
    profile?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    refreshToken?: StringWithAggregatesFilter<"Session"> | string
    userAgent?: StringNullableWithAggregatesFilter<"Session"> | string | null
    ip?: StringNullableWithAggregatesFilter<"Session"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Session"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"Session"> | Date | string | null
  }

  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: StringFilter<"Page"> | string
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    body?: StringFilter<"Page"> | string
    status?: EnumPageStatusFilter<"Page"> | $Enums.PageStatus
    meta?: JsonNullableFilter<"Page">
    createdById?: StringFilter<"Page"> | string
    updatedById?: StringNullableFilter<"Page"> | string | null
    publishedAt?: DateTimeNullableFilter<"Page"> | Date | string | null
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    body?: SortOrder
    status?: SortOrder
    meta?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdBy?: UserOrderByWithRelationInput
    updatedBy?: UserOrderByWithRelationInput
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    title?: StringFilter<"Page"> | string
    body?: StringFilter<"Page"> | string
    status?: EnumPageStatusFilter<"Page"> | $Enums.PageStatus
    meta?: JsonNullableFilter<"Page">
    createdById?: StringFilter<"Page"> | string
    updatedById?: StringNullableFilter<"Page"> | string | null
    publishedAt?: DateTimeNullableFilter<"Page"> | Date | string | null
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    updatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "slug">

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    body?: SortOrder
    status?: SortOrder
    meta?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Page"> | string
    title?: StringWithAggregatesFilter<"Page"> | string
    slug?: StringWithAggregatesFilter<"Page"> | string
    body?: StringWithAggregatesFilter<"Page"> | string
    status?: EnumPageStatusWithAggregatesFilter<"Page"> | $Enums.PageStatus
    meta?: JsonNullableWithAggregatesFilter<"Page">
    createdById?: StringWithAggregatesFilter<"Page"> | string
    updatedById?: StringNullableWithAggregatesFilter<"Page"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Page"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Page"> | Date | string
  }

  export type UploadAssetWhereInput = {
    AND?: UploadAssetWhereInput | UploadAssetWhereInput[]
    OR?: UploadAssetWhereInput[]
    NOT?: UploadAssetWhereInput | UploadAssetWhereInput[]
    id?: StringFilter<"UploadAsset"> | string
    objectKey?: StringFilter<"UploadAsset"> | string
    contentType?: StringFilter<"UploadAsset"> | string
    size?: IntFilter<"UploadAsset"> | number
    publicUrl?: StringNullableFilter<"UploadAsset"> | string | null
    context?: StringNullableFilter<"UploadAsset"> | string | null
    uploaderId?: StringNullableFilter<"UploadAsset"> | string | null
    createdAt?: DateTimeFilter<"UploadAsset"> | Date | string
    uploader?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type UploadAssetOrderByWithRelationInput = {
    id?: SortOrder
    objectKey?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    publicUrl?: SortOrder
    context?: SortOrder
    uploaderId?: SortOrder
    createdAt?: SortOrder
    uploader?: UserOrderByWithRelationInput
  }

  export type UploadAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    objectKey?: string
    AND?: UploadAssetWhereInput | UploadAssetWhereInput[]
    OR?: UploadAssetWhereInput[]
    NOT?: UploadAssetWhereInput | UploadAssetWhereInput[]
    contentType?: StringFilter<"UploadAsset"> | string
    size?: IntFilter<"UploadAsset"> | number
    publicUrl?: StringNullableFilter<"UploadAsset"> | string | null
    context?: StringNullableFilter<"UploadAsset"> | string | null
    uploaderId?: StringNullableFilter<"UploadAsset"> | string | null
    createdAt?: DateTimeFilter<"UploadAsset"> | Date | string
    uploader?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id" | "objectKey">

  export type UploadAssetOrderByWithAggregationInput = {
    id?: SortOrder
    objectKey?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    publicUrl?: SortOrder
    context?: SortOrder
    uploaderId?: SortOrder
    createdAt?: SortOrder
    _count?: UploadAssetCountOrderByAggregateInput
    _avg?: UploadAssetAvgOrderByAggregateInput
    _max?: UploadAssetMaxOrderByAggregateInput
    _min?: UploadAssetMinOrderByAggregateInput
    _sum?: UploadAssetSumOrderByAggregateInput
  }

  export type UploadAssetScalarWhereWithAggregatesInput = {
    AND?: UploadAssetScalarWhereWithAggregatesInput | UploadAssetScalarWhereWithAggregatesInput[]
    OR?: UploadAssetScalarWhereWithAggregatesInput[]
    NOT?: UploadAssetScalarWhereWithAggregatesInput | UploadAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UploadAsset"> | string
    objectKey?: StringWithAggregatesFilter<"UploadAsset"> | string
    contentType?: StringWithAggregatesFilter<"UploadAsset"> | string
    size?: IntWithAggregatesFilter<"UploadAsset"> | number
    publicUrl?: StringNullableWithAggregatesFilter<"UploadAsset"> | string | null
    context?: StringNullableWithAggregatesFilter<"UploadAsset"> | string | null
    uploaderId?: StringNullableWithAggregatesFilter<"UploadAsset"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UploadAsset"> | Date | string
  }

  export type InstallationWhereInput = {
    AND?: InstallationWhereInput | InstallationWhereInput[]
    OR?: InstallationWhereInput[]
    NOT?: InstallationWhereInput | InstallationWhereInput[]
    id?: StringFilter<"Installation"> | string
    dealerId?: StringNullableFilter<"Installation"> | string | null
    siteName?: StringFilter<"Installation"> | string
    address?: JsonNullableFilter<"Installation">
    customerInfo?: JsonNullableFilter<"Installation">
    scheduledAt?: DateTimeNullableFilter<"Installation"> | Date | string | null
    status?: EnumInstallStatusFilter<"Installation"> | $Enums.InstallStatus
    notes?: StringNullableFilter<"Installation"> | string | null
    createdAt?: DateTimeFilter<"Installation"> | Date | string
    updatedAt?: DateTimeFilter<"Installation"> | Date | string
    reports?: ReportListRelationFilter
  }

  export type InstallationOrderByWithRelationInput = {
    id?: SortOrder
    dealerId?: SortOrder
    siteName?: SortOrder
    address?: SortOrder
    customerInfo?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reports?: ReportOrderByRelationAggregateInput
  }

  export type InstallationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InstallationWhereInput | InstallationWhereInput[]
    OR?: InstallationWhereInput[]
    NOT?: InstallationWhereInput | InstallationWhereInput[]
    dealerId?: StringNullableFilter<"Installation"> | string | null
    siteName?: StringFilter<"Installation"> | string
    address?: JsonNullableFilter<"Installation">
    customerInfo?: JsonNullableFilter<"Installation">
    scheduledAt?: DateTimeNullableFilter<"Installation"> | Date | string | null
    status?: EnumInstallStatusFilter<"Installation"> | $Enums.InstallStatus
    notes?: StringNullableFilter<"Installation"> | string | null
    createdAt?: DateTimeFilter<"Installation"> | Date | string
    updatedAt?: DateTimeFilter<"Installation"> | Date | string
    reports?: ReportListRelationFilter
  }, "id">

  export type InstallationOrderByWithAggregationInput = {
    id?: SortOrder
    dealerId?: SortOrder
    siteName?: SortOrder
    address?: SortOrder
    customerInfo?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstallationCountOrderByAggregateInput
    _max?: InstallationMaxOrderByAggregateInput
    _min?: InstallationMinOrderByAggregateInput
  }

  export type InstallationScalarWhereWithAggregatesInput = {
    AND?: InstallationScalarWhereWithAggregatesInput | InstallationScalarWhereWithAggregatesInput[]
    OR?: InstallationScalarWhereWithAggregatesInput[]
    NOT?: InstallationScalarWhereWithAggregatesInput | InstallationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Installation"> | string
    dealerId?: StringNullableWithAggregatesFilter<"Installation"> | string | null
    siteName?: StringWithAggregatesFilter<"Installation"> | string
    address?: JsonNullableWithAggregatesFilter<"Installation">
    customerInfo?: JsonNullableWithAggregatesFilter<"Installation">
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Installation"> | Date | string | null
    status?: EnumInstallStatusWithAggregatesFilter<"Installation"> | $Enums.InstallStatus
    notes?: StringNullableWithAggregatesFilter<"Installation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Installation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Installation"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: StringFilter<"Report"> | string
    installationId?: StringFilter<"Report"> | string
    reportType?: StringFilter<"Report"> | string
    notes?: StringNullableFilter<"Report"> | string | null
    uploadObjectKey?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    installation?: XOR<InstallationRelationFilter, InstallationWhereInput>
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    installationId?: SortOrder
    reportType?: SortOrder
    notes?: SortOrder
    uploadObjectKey?: SortOrder
    createdAt?: SortOrder
    installation?: InstallationOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    installationId?: StringFilter<"Report"> | string
    reportType?: StringFilter<"Report"> | string
    notes?: StringNullableFilter<"Report"> | string | null
    uploadObjectKey?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
    installation?: XOR<InstallationRelationFilter, InstallationWhereInput>
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    installationId?: SortOrder
    reportType?: SortOrder
    notes?: SortOrder
    uploadObjectKey?: SortOrder
    createdAt?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Report"> | string
    installationId?: StringWithAggregatesFilter<"Report"> | string
    reportType?: StringWithAggregatesFilter<"Report"> | string
    notes?: StringNullableWithAggregatesFilter<"Report"> | string | null
    uploadObjectKey?: StringWithAggregatesFilter<"Report"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
  }

  export type AuditEventWhereInput = {
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    id?: StringFilter<"AuditEvent"> | string
    actorId?: StringNullableFilter<"AuditEvent"> | string | null
    action?: StringFilter<"AuditEvent"> | string
    target?: StringNullableFilter<"AuditEvent"> | string | null
    meta?: JsonNullableFilter<"AuditEvent">
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditEventOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
  }

  export type AuditEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditEventWhereInput | AuditEventWhereInput[]
    OR?: AuditEventWhereInput[]
    NOT?: AuditEventWhereInput | AuditEventWhereInput[]
    actorId?: StringNullableFilter<"AuditEvent"> | string | null
    action?: StringFilter<"AuditEvent"> | string
    target?: StringNullableFilter<"AuditEvent"> | string | null
    meta?: JsonNullableFilter<"AuditEvent">
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditEventOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
    _count?: AuditEventCountOrderByAggregateInput
    _max?: AuditEventMaxOrderByAggregateInput
    _min?: AuditEventMinOrderByAggregateInput
  }

  export type AuditEventScalarWhereWithAggregatesInput = {
    AND?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    OR?: AuditEventScalarWhereWithAggregatesInput[]
    NOT?: AuditEventScalarWhereWithAggregatesInput | AuditEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditEvent"> | string
    actorId?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    action?: StringWithAggregatesFilter<"AuditEvent"> | string
    target?: StringNullableWithAggregatesFilter<"AuditEvent"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"AuditEvent">
    createdAt?: DateTimeWithAggregatesFilter<"AuditEvent"> | Date | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    name?: StringFilter<"Lead"> | string
    email?: StringFilter<"Lead"> | string
    phone?: StringNullableFilter<"Lead"> | string | null
    company?: StringNullableFilter<"Lead"> | string | null
    country?: StringNullableFilter<"Lead"> | string | null
    type?: EnumLeadTypeFilter<"Lead"> | $Enums.LeadType
    message?: StringNullableFilter<"Lead"> | string | null
    tags?: StringNullableListFilter<"Lead">
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    owner?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    country?: SortOrder
    type?: SortOrder
    message?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    owner?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    name?: StringFilter<"Lead"> | string
    email?: StringFilter<"Lead"> | string
    phone?: StringNullableFilter<"Lead"> | string | null
    company?: StringNullableFilter<"Lead"> | string | null
    country?: StringNullableFilter<"Lead"> | string | null
    type?: EnumLeadTypeFilter<"Lead"> | $Enums.LeadType
    message?: StringNullableFilter<"Lead"> | string | null
    tags?: StringNullableListFilter<"Lead">
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    owner?: StringNullableFilter<"Lead"> | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    country?: SortOrder
    type?: SortOrder
    message?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    owner?: SortOrder
    createdAt?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    name?: StringWithAggregatesFilter<"Lead"> | string
    email?: StringWithAggregatesFilter<"Lead"> | string
    phone?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    company?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    country?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    type?: EnumLeadTypeWithAggregatesFilter<"Lead"> | $Enums.LeadType
    message?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    tags?: StringNullableListFilter<"Lead">
    status?: EnumLeadStatusWithAggregatesFilter<"Lead"> | $Enums.LeadStatus
    owner?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
  }

  export type DealerWhereInput = {
    AND?: DealerWhereInput | DealerWhereInput[]
    OR?: DealerWhereInput[]
    NOT?: DealerWhereInput | DealerWhereInput[]
    id?: StringFilter<"Dealer"> | string
    org?: StringFilter<"Dealer"> | string
    contactName?: StringFilter<"Dealer"> | string
    contactEmail?: StringFilter<"Dealer"> | string
    region?: StringFilter<"Dealer"> | string
    status?: EnumDealerStatusFilter<"Dealer"> | $Enums.DealerStatus
    users?: IntFilter<"Dealer"> | number
    last?: DateTimeFilter<"Dealer"> | Date | string
    createdAt?: DateTimeFilter<"Dealer"> | Date | string
    updatedAt?: DateTimeFilter<"Dealer"> | Date | string
  }

  export type DealerOrderByWithRelationInput = {
    id?: SortOrder
    org?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    region?: SortOrder
    status?: SortOrder
    users?: SortOrder
    last?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealerWhereInput | DealerWhereInput[]
    OR?: DealerWhereInput[]
    NOT?: DealerWhereInput | DealerWhereInput[]
    org?: StringFilter<"Dealer"> | string
    contactName?: StringFilter<"Dealer"> | string
    contactEmail?: StringFilter<"Dealer"> | string
    region?: StringFilter<"Dealer"> | string
    status?: EnumDealerStatusFilter<"Dealer"> | $Enums.DealerStatus
    users?: IntFilter<"Dealer"> | number
    last?: DateTimeFilter<"Dealer"> | Date | string
    createdAt?: DateTimeFilter<"Dealer"> | Date | string
    updatedAt?: DateTimeFilter<"Dealer"> | Date | string
  }, "id">

  export type DealerOrderByWithAggregationInput = {
    id?: SortOrder
    org?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    region?: SortOrder
    status?: SortOrder
    users?: SortOrder
    last?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DealerCountOrderByAggregateInput
    _avg?: DealerAvgOrderByAggregateInput
    _max?: DealerMaxOrderByAggregateInput
    _min?: DealerMinOrderByAggregateInput
    _sum?: DealerSumOrderByAggregateInput
  }

  export type DealerScalarWhereWithAggregatesInput = {
    AND?: DealerScalarWhereWithAggregatesInput | DealerScalarWhereWithAggregatesInput[]
    OR?: DealerScalarWhereWithAggregatesInput[]
    NOT?: DealerScalarWhereWithAggregatesInput | DealerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Dealer"> | string
    org?: StringWithAggregatesFilter<"Dealer"> | string
    contactName?: StringWithAggregatesFilter<"Dealer"> | string
    contactEmail?: StringWithAggregatesFilter<"Dealer"> | string
    region?: StringWithAggregatesFilter<"Dealer"> | string
    status?: EnumDealerStatusWithAggregatesFilter<"Dealer"> | $Enums.DealerStatus
    users?: IntWithAggregatesFilter<"Dealer"> | number
    last?: DateTimeWithAggregatesFilter<"Dealer"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Dealer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dealer"> | Date | string
  }

  export type FileAssetWhereInput = {
    AND?: FileAssetWhereInput | FileAssetWhereInput[]
    OR?: FileAssetWhereInput[]
    NOT?: FileAssetWhereInput | FileAssetWhereInput[]
    id?: StringFilter<"FileAsset"> | string
    name?: StringFilter<"FileAsset"> | string
    type?: EnumFileTypeFilter<"FileAsset"> | $Enums.FileType
    cat?: EnumFileCategoryFilter<"FileAsset"> | $Enums.FileCategory
    vis?: EnumFileVisibilityFilter<"FileAsset"> | $Enums.FileVisibility
    url?: StringFilter<"FileAsset"> | string
    desc?: StringNullableFilter<"FileAsset"> | string | null
    size?: IntNullableFilter<"FileAsset"> | number | null
    createdAt?: DateTimeFilter<"FileAsset"> | Date | string
    updatedAt?: DateTimeFilter<"FileAsset"> | Date | string
  }

  export type FileAssetOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cat?: SortOrder
    vis?: SortOrder
    url?: SortOrder
    desc?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileAssetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileAssetWhereInput | FileAssetWhereInput[]
    OR?: FileAssetWhereInput[]
    NOT?: FileAssetWhereInput | FileAssetWhereInput[]
    name?: StringFilter<"FileAsset"> | string
    type?: EnumFileTypeFilter<"FileAsset"> | $Enums.FileType
    cat?: EnumFileCategoryFilter<"FileAsset"> | $Enums.FileCategory
    vis?: EnumFileVisibilityFilter<"FileAsset"> | $Enums.FileVisibility
    url?: StringFilter<"FileAsset"> | string
    desc?: StringNullableFilter<"FileAsset"> | string | null
    size?: IntNullableFilter<"FileAsset"> | number | null
    createdAt?: DateTimeFilter<"FileAsset"> | Date | string
    updatedAt?: DateTimeFilter<"FileAsset"> | Date | string
  }, "id">

  export type FileAssetOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cat?: SortOrder
    vis?: SortOrder
    url?: SortOrder
    desc?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FileAssetCountOrderByAggregateInput
    _avg?: FileAssetAvgOrderByAggregateInput
    _max?: FileAssetMaxOrderByAggregateInput
    _min?: FileAssetMinOrderByAggregateInput
    _sum?: FileAssetSumOrderByAggregateInput
  }

  export type FileAssetScalarWhereWithAggregatesInput = {
    AND?: FileAssetScalarWhereWithAggregatesInput | FileAssetScalarWhereWithAggregatesInput[]
    OR?: FileAssetScalarWhereWithAggregatesInput[]
    NOT?: FileAssetScalarWhereWithAggregatesInput | FileAssetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileAsset"> | string
    name?: StringWithAggregatesFilter<"FileAsset"> | string
    type?: EnumFileTypeWithAggregatesFilter<"FileAsset"> | $Enums.FileType
    cat?: EnumFileCategoryWithAggregatesFilter<"FileAsset"> | $Enums.FileCategory
    vis?: EnumFileVisibilityWithAggregatesFilter<"FileAsset"> | $Enums.FileVisibility
    url?: StringWithAggregatesFilter<"FileAsset"> | string
    desc?: StringNullableWithAggregatesFilter<"FileAsset"> | string | null
    size?: IntNullableWithAggregatesFilter<"FileAsset"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"FileAsset"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FileAsset"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    code?: StringNullableFilter<"Product"> | string | null
    variant?: StringNullableFilter<"Product"> | string | null
    short?: StringNullableFilter<"Product"> | string | null
    long?: StringNullableFilter<"Product"> | string | null
    bullets?: StringNullableFilter<"Product"> | string | null
    nij?: StringNullableFilter<"Product"> | string | null
    thickness?: StringNullableFilter<"Product"> | string | null
    vlt?: StringNullableFilter<"Product"> | string | null
    impact?: StringNullableFilter<"Product"> | string | null
    images?: StringNullableListFilter<"Product">
    datasheet?: StringNullableFilter<"Product"> | string | null
    slug?: StringFilter<"Product"> | string
    metaTitle?: StringNullableFilter<"Product"> | string | null
    metaDesc?: StringNullableFilter<"Product"> | string | null
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    variant?: SortOrder
    short?: SortOrder
    long?: SortOrder
    bullets?: SortOrder
    nij?: SortOrder
    thickness?: SortOrder
    vlt?: SortOrder
    impact?: SortOrder
    images?: SortOrder
    datasheet?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrder
    metaDesc?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    code?: StringNullableFilter<"Product"> | string | null
    variant?: StringNullableFilter<"Product"> | string | null
    short?: StringNullableFilter<"Product"> | string | null
    long?: StringNullableFilter<"Product"> | string | null
    bullets?: StringNullableFilter<"Product"> | string | null
    nij?: StringNullableFilter<"Product"> | string | null
    thickness?: StringNullableFilter<"Product"> | string | null
    vlt?: StringNullableFilter<"Product"> | string | null
    impact?: StringNullableFilter<"Product"> | string | null
    images?: StringNullableListFilter<"Product">
    datasheet?: StringNullableFilter<"Product"> | string | null
    metaTitle?: StringNullableFilter<"Product"> | string | null
    metaDesc?: StringNullableFilter<"Product"> | string | null
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    createdAt?: DateTimeFilter<"Product"> | Date | string
  }, "id" | "slug">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    variant?: SortOrder
    short?: SortOrder
    long?: SortOrder
    bullets?: SortOrder
    nij?: SortOrder
    thickness?: SortOrder
    vlt?: SortOrder
    impact?: SortOrder
    images?: SortOrder
    datasheet?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrder
    metaDesc?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    code?: StringNullableWithAggregatesFilter<"Product"> | string | null
    variant?: StringNullableWithAggregatesFilter<"Product"> | string | null
    short?: StringNullableWithAggregatesFilter<"Product"> | string | null
    long?: StringNullableWithAggregatesFilter<"Product"> | string | null
    bullets?: StringNullableWithAggregatesFilter<"Product"> | string | null
    nij?: StringNullableWithAggregatesFilter<"Product"> | string | null
    thickness?: StringNullableWithAggregatesFilter<"Product"> | string | null
    vlt?: StringNullableWithAggregatesFilter<"Product"> | string | null
    impact?: StringNullableWithAggregatesFilter<"Product"> | string | null
    images?: StringNullableListFilter<"Product">
    datasheet?: StringNullableWithAggregatesFilter<"Product"> | string | null
    slug?: StringWithAggregatesFilter<"Product"> | string
    metaTitle?: StringNullableWithAggregatesFilter<"Product"> | string | null
    metaDesc?: StringNullableWithAggregatesFilter<"Product"> | string | null
    status?: EnumProductStatusWithAggregatesFilter<"Product"> | $Enums.ProductStatus
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type DealerUploadWhereInput = {
    AND?: DealerUploadWhereInput | DealerUploadWhereInput[]
    OR?: DealerUploadWhereInput[]
    NOT?: DealerUploadWhereInput | DealerUploadWhereInput[]
    id?: StringFilter<"DealerUpload"> | string
    userId?: StringFilter<"DealerUpload"> | string
    email?: StringFilter<"DealerUpload"> | string
    name?: StringFilter<"DealerUpload"> | string
    category?: StringFilter<"DealerUpload"> | string
    description?: StringNullableFilter<"DealerUpload"> | string | null
    status?: EnumDealerUploadStatusFilter<"DealerUpload"> | $Enums.DealerUploadStatus
    reviewerId?: StringNullableFilter<"DealerUpload"> | string | null
    reviewNote?: StringNullableFilter<"DealerUpload"> | string | null
    createdAt?: DateTimeFilter<"DealerUpload"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"DealerUpload"> | Date | string | null
  }

  export type DealerUploadOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrder
    reviewNote?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type DealerUploadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealerUploadWhereInput | DealerUploadWhereInput[]
    OR?: DealerUploadWhereInput[]
    NOT?: DealerUploadWhereInput | DealerUploadWhereInput[]
    userId?: StringFilter<"DealerUpload"> | string
    email?: StringFilter<"DealerUpload"> | string
    name?: StringFilter<"DealerUpload"> | string
    category?: StringFilter<"DealerUpload"> | string
    description?: StringNullableFilter<"DealerUpload"> | string | null
    status?: EnumDealerUploadStatusFilter<"DealerUpload"> | $Enums.DealerUploadStatus
    reviewerId?: StringNullableFilter<"DealerUpload"> | string | null
    reviewNote?: StringNullableFilter<"DealerUpload"> | string | null
    createdAt?: DateTimeFilter<"DealerUpload"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"DealerUpload"> | Date | string | null
  }, "id">

  export type DealerUploadOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrder
    reviewNote?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrder
    _count?: DealerUploadCountOrderByAggregateInput
    _max?: DealerUploadMaxOrderByAggregateInput
    _min?: DealerUploadMinOrderByAggregateInput
  }

  export type DealerUploadScalarWhereWithAggregatesInput = {
    AND?: DealerUploadScalarWhereWithAggregatesInput | DealerUploadScalarWhereWithAggregatesInput[]
    OR?: DealerUploadScalarWhereWithAggregatesInput[]
    NOT?: DealerUploadScalarWhereWithAggregatesInput | DealerUploadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DealerUpload"> | string
    userId?: StringWithAggregatesFilter<"DealerUpload"> | string
    email?: StringWithAggregatesFilter<"DealerUpload"> | string
    name?: StringWithAggregatesFilter<"DealerUpload"> | string
    category?: StringWithAggregatesFilter<"DealerUpload"> | string
    description?: StringNullableWithAggregatesFilter<"DealerUpload"> | string | null
    status?: EnumDealerUploadStatusWithAggregatesFilter<"DealerUpload"> | $Enums.DealerUploadStatus
    reviewerId?: StringNullableWithAggregatesFilter<"DealerUpload"> | string | null
    reviewNote?: StringNullableWithAggregatesFilter<"DealerUpload"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DealerUpload"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"DealerUpload"> | Date | string | null
  }

  export type TrainingEventWhereInput = {
    AND?: TrainingEventWhereInput | TrainingEventWhereInput[]
    OR?: TrainingEventWhereInput[]
    NOT?: TrainingEventWhereInput | TrainingEventWhereInput[]
    id?: StringFilter<"TrainingEvent"> | string
    title?: StringFilter<"TrainingEvent"> | string
    datetime?: DateTimeFilter<"TrainingEvent"> | Date | string
    mode?: EnumTrainingModeFilter<"TrainingEvent"> | $Enums.TrainingMode
    location?: StringNullableFilter<"TrainingEvent"> | string | null
    desc?: StringNullableFilter<"TrainingEvent"> | string | null
    status?: EnumTrainingStatusFilter<"TrainingEvent"> | $Enums.TrainingStatus
    createdAt?: DateTimeFilter<"TrainingEvent"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingEvent"> | Date | string
  }

  export type TrainingEventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    datetime?: SortOrder
    mode?: SortOrder
    location?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingEventWhereInput | TrainingEventWhereInput[]
    OR?: TrainingEventWhereInput[]
    NOT?: TrainingEventWhereInput | TrainingEventWhereInput[]
    title?: StringFilter<"TrainingEvent"> | string
    datetime?: DateTimeFilter<"TrainingEvent"> | Date | string
    mode?: EnumTrainingModeFilter<"TrainingEvent"> | $Enums.TrainingMode
    location?: StringNullableFilter<"TrainingEvent"> | string | null
    desc?: StringNullableFilter<"TrainingEvent"> | string | null
    status?: EnumTrainingStatusFilter<"TrainingEvent"> | $Enums.TrainingStatus
    createdAt?: DateTimeFilter<"TrainingEvent"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingEvent"> | Date | string
  }, "id">

  export type TrainingEventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    datetime?: SortOrder
    mode?: SortOrder
    location?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingEventCountOrderByAggregateInput
    _max?: TrainingEventMaxOrderByAggregateInput
    _min?: TrainingEventMinOrderByAggregateInput
  }

  export type TrainingEventScalarWhereWithAggregatesInput = {
    AND?: TrainingEventScalarWhereWithAggregatesInput | TrainingEventScalarWhereWithAggregatesInput[]
    OR?: TrainingEventScalarWhereWithAggregatesInput[]
    NOT?: TrainingEventScalarWhereWithAggregatesInput | TrainingEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingEvent"> | string
    title?: StringWithAggregatesFilter<"TrainingEvent"> | string
    datetime?: DateTimeWithAggregatesFilter<"TrainingEvent"> | Date | string
    mode?: EnumTrainingModeWithAggregatesFilter<"TrainingEvent"> | $Enums.TrainingMode
    location?: StringNullableWithAggregatesFilter<"TrainingEvent"> | string | null
    desc?: StringNullableWithAggregatesFilter<"TrainingEvent"> | string | null
    status?: EnumTrainingStatusWithAggregatesFilter<"TrainingEvent"> | $Enums.TrainingStatus
    createdAt?: DateTimeWithAggregatesFilter<"TrainingEvent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingEvent"> | Date | string
  }

  export type TrainingRegistrationWhereInput = {
    AND?: TrainingRegistrationWhereInput | TrainingRegistrationWhereInput[]
    OR?: TrainingRegistrationWhereInput[]
    NOT?: TrainingRegistrationWhereInput | TrainingRegistrationWhereInput[]
    id?: StringFilter<"TrainingRegistration"> | string
    eventId?: StringFilter<"TrainingRegistration"> | string
    userId?: StringFilter<"TrainingRegistration"> | string
    note?: StringNullableFilter<"TrainingRegistration"> | string | null
    status?: StringFilter<"TrainingRegistration"> | string
    createdAt?: DateTimeFilter<"TrainingRegistration"> | Date | string
  }

  export type TrainingRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingRegistrationWhereInput | TrainingRegistrationWhereInput[]
    OR?: TrainingRegistrationWhereInput[]
    NOT?: TrainingRegistrationWhereInput | TrainingRegistrationWhereInput[]
    eventId?: StringFilter<"TrainingRegistration"> | string
    userId?: StringFilter<"TrainingRegistration"> | string
    note?: StringNullableFilter<"TrainingRegistration"> | string | null
    status?: StringFilter<"TrainingRegistration"> | string
    createdAt?: DateTimeFilter<"TrainingRegistration"> | Date | string
  }, "id">

  export type TrainingRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: TrainingRegistrationCountOrderByAggregateInput
    _max?: TrainingRegistrationMaxOrderByAggregateInput
    _min?: TrainingRegistrationMinOrderByAggregateInput
  }

  export type TrainingRegistrationScalarWhereWithAggregatesInput = {
    AND?: TrainingRegistrationScalarWhereWithAggregatesInput | TrainingRegistrationScalarWhereWithAggregatesInput[]
    OR?: TrainingRegistrationScalarWhereWithAggregatesInput[]
    NOT?: TrainingRegistrationScalarWhereWithAggregatesInput | TrainingRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingRegistration"> | string
    eventId?: StringWithAggregatesFilter<"TrainingRegistration"> | string
    userId?: StringWithAggregatesFilter<"TrainingRegistration"> | string
    note?: StringNullableWithAggregatesFilter<"TrainingRegistration"> | string | null
    status?: StringWithAggregatesFilter<"TrainingRegistration"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TrainingRegistration"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    uploads?: UploadAssetCreateNestedManyWithoutUploaderInput
    pagesCreated?: PageCreateNestedManyWithoutCreatedByInput
    pagesUpdated?: PageCreateNestedManyWithoutUpdatedByInput
    auditEvents?: AuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    uploads?: UploadAssetUncheckedCreateNestedManyWithoutUploaderInput
    pagesCreated?: PageUncheckedCreateNestedManyWithoutCreatedByInput
    pagesUpdated?: PageUncheckedCreateNestedManyWithoutUpdatedByInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    uploads?: UploadAssetUpdateManyWithoutUploaderNestedInput
    pagesCreated?: PageUpdateManyWithoutCreatedByNestedInput
    pagesUpdated?: PageUpdateManyWithoutUpdatedByNestedInput
    auditEvents?: AuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    uploads?: UploadAssetUncheckedUpdateManyWithoutUploaderNestedInput
    pagesCreated?: PageUncheckedUpdateManyWithoutCreatedByNestedInput
    pagesUpdated?: PageUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ip?: string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    userId: string
    refreshToken: string
    userAgent?: string | null
    ip?: string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type SessionUpdateInput = {
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionCreateManyInput = {
    id?: string
    userId: string
    refreshToken: string
    userAgent?: string | null
    ip?: string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type SessionUpdateManyMutationInput = {
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PageCreateInput = {
    id?: string
    title: string
    slug: string
    body: string
    status?: $Enums.PageStatus
    meta?: InputJsonValue | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPagesCreatedInput
    updatedBy?: UserCreateNestedOneWithoutPagesUpdatedInput
  }

  export type PageUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    body: string
    status?: $Enums.PageStatus
    meta?: InputJsonValue | null
    createdById: string
    updatedById?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumPageStatusFieldUpdateOperationsInput | $Enums.PageStatus
    meta?: InputJsonValue | InputJsonValue | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPagesCreatedNestedInput
    updatedBy?: UserUpdateOneWithoutPagesUpdatedNestedInput
  }

  export type PageUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumPageStatusFieldUpdateOperationsInput | $Enums.PageStatus
    meta?: InputJsonValue | InputJsonValue | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateManyInput = {
    id?: string
    title: string
    slug: string
    body: string
    status?: $Enums.PageStatus
    meta?: InputJsonValue | null
    createdById: string
    updatedById?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumPageStatusFieldUpdateOperationsInput | $Enums.PageStatus
    meta?: InputJsonValue | InputJsonValue | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumPageStatusFieldUpdateOperationsInput | $Enums.PageStatus
    meta?: InputJsonValue | InputJsonValue | null
    createdById?: StringFieldUpdateOperationsInput | string
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadAssetCreateInput = {
    id?: string
    objectKey: string
    contentType: string
    size: number
    publicUrl?: string | null
    context?: string | null
    createdAt?: Date | string
    uploader?: UserCreateNestedOneWithoutUploadsInput
  }

  export type UploadAssetUncheckedCreateInput = {
    id?: string
    objectKey: string
    contentType: string
    size: number
    publicUrl?: string | null
    context?: string | null
    uploaderId?: string | null
    createdAt?: Date | string
  }

  export type UploadAssetUpdateInput = {
    objectKey?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneWithoutUploadsNestedInput
  }

  export type UploadAssetUncheckedUpdateInput = {
    objectKey?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadAssetCreateManyInput = {
    id?: string
    objectKey: string
    contentType: string
    size: number
    publicUrl?: string | null
    context?: string | null
    uploaderId?: string | null
    createdAt?: Date | string
  }

  export type UploadAssetUpdateManyMutationInput = {
    objectKey?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadAssetUncheckedUpdateManyInput = {
    objectKey?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    uploaderId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallationCreateInput = {
    id?: string
    dealerId?: string | null
    siteName: string
    address?: InputJsonValue | null
    customerInfo?: InputJsonValue | null
    scheduledAt?: Date | string | null
    status?: $Enums.InstallStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportCreateNestedManyWithoutInstallationInput
  }

  export type InstallationUncheckedCreateInput = {
    id?: string
    dealerId?: string | null
    siteName: string
    address?: InputJsonValue | null
    customerInfo?: InputJsonValue | null
    scheduledAt?: Date | string | null
    status?: $Enums.InstallStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutInstallationInput
  }

  export type InstallationUpdateInput = {
    dealerId?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: StringFieldUpdateOperationsInput | string
    address?: InputJsonValue | InputJsonValue | null
    customerInfo?: InputJsonValue | InputJsonValue | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInstallStatusFieldUpdateOperationsInput | $Enums.InstallStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUpdateManyWithoutInstallationNestedInput
  }

  export type InstallationUncheckedUpdateInput = {
    dealerId?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: StringFieldUpdateOperationsInput | string
    address?: InputJsonValue | InputJsonValue | null
    customerInfo?: InputJsonValue | InputJsonValue | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInstallStatusFieldUpdateOperationsInput | $Enums.InstallStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutInstallationNestedInput
  }

  export type InstallationCreateManyInput = {
    id?: string
    dealerId?: string | null
    siteName: string
    address?: InputJsonValue | null
    customerInfo?: InputJsonValue | null
    scheduledAt?: Date | string | null
    status?: $Enums.InstallStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallationUpdateManyMutationInput = {
    dealerId?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: StringFieldUpdateOperationsInput | string
    address?: InputJsonValue | InputJsonValue | null
    customerInfo?: InputJsonValue | InputJsonValue | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInstallStatusFieldUpdateOperationsInput | $Enums.InstallStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallationUncheckedUpdateManyInput = {
    dealerId?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: StringFieldUpdateOperationsInput | string
    address?: InputJsonValue | InputJsonValue | null
    customerInfo?: InputJsonValue | InputJsonValue | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInstallStatusFieldUpdateOperationsInput | $Enums.InstallStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    id?: string
    reportType: string
    notes?: string | null
    uploadObjectKey: string
    createdAt?: Date | string
    installation: InstallationCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateInput = {
    id?: string
    installationId: string
    reportType: string
    notes?: string | null
    uploadObjectKey: string
    createdAt?: Date | string
  }

  export type ReportUpdateInput = {
    reportType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadObjectKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    installation?: InstallationUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    installationId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadObjectKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInput = {
    id?: string
    installationId: string
    reportType: string
    notes?: string | null
    uploadObjectKey: string
    createdAt?: Date | string
  }

  export type ReportUpdateManyMutationInput = {
    reportType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadObjectKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyInput = {
    installationId?: StringFieldUpdateOperationsInput | string
    reportType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadObjectKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventCreateInput = {
    id?: string
    action: string
    target?: string | null
    meta?: InputJsonValue | null
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutAuditEventsInput
  }

  export type AuditEventUncheckedCreateInput = {
    id?: string
    actorId?: string | null
    action: string
    target?: string | null
    meta?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type AuditEventUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutAuditEventsNestedInput
  }

  export type AuditEventUncheckedUpdateInput = {
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventCreateManyInput = {
    id?: string
    actorId?: string | null
    action: string
    target?: string | null
    meta?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type AuditEventUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyInput = {
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    country?: string | null
    type: $Enums.LeadType
    message?: string | null
    tags?: LeadCreatetagsInput | string[]
    status?: $Enums.LeadStatus
    owner?: string | null
    createdAt?: Date | string
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    country?: string | null
    type: $Enums.LeadType
    message?: string | null
    tags?: LeadCreatetagsInput | string[]
    status?: $Enums.LeadStatus
    owner?: string | null
    createdAt?: Date | string
  }

  export type LeadUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLeadTypeFieldUpdateOperationsInput | $Enums.LeadType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLeadTypeFieldUpdateOperationsInput | $Enums.LeadType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    company?: string | null
    country?: string | null
    type: $Enums.LeadType
    message?: string | null
    tags?: LeadCreatetagsInput | string[]
    status?: $Enums.LeadStatus
    owner?: string | null
    createdAt?: Date | string
  }

  export type LeadUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLeadTypeFieldUpdateOperationsInput | $Enums.LeadType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLeadTypeFieldUpdateOperationsInput | $Enums.LeadType
    message?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: LeadUpdatetagsInput | string[]
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    owner?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealerCreateInput = {
    id?: string
    org: string
    contactName: string
    contactEmail: string
    region: string
    status?: $Enums.DealerStatus
    users?: number
    last?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealerUncheckedCreateInput = {
    id?: string
    org: string
    contactName: string
    contactEmail: string
    region: string
    status?: $Enums.DealerStatus
    users?: number
    last?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealerUpdateInput = {
    org?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    status?: EnumDealerStatusFieldUpdateOperationsInput | $Enums.DealerStatus
    users?: IntFieldUpdateOperationsInput | number
    last?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealerUncheckedUpdateInput = {
    org?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    status?: EnumDealerStatusFieldUpdateOperationsInput | $Enums.DealerStatus
    users?: IntFieldUpdateOperationsInput | number
    last?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealerCreateManyInput = {
    id?: string
    org: string
    contactName: string
    contactEmail: string
    region: string
    status?: $Enums.DealerStatus
    users?: number
    last?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealerUpdateManyMutationInput = {
    org?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    status?: EnumDealerStatusFieldUpdateOperationsInput | $Enums.DealerStatus
    users?: IntFieldUpdateOperationsInput | number
    last?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealerUncheckedUpdateManyInput = {
    org?: StringFieldUpdateOperationsInput | string
    contactName?: StringFieldUpdateOperationsInput | string
    contactEmail?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    status?: EnumDealerStatusFieldUpdateOperationsInput | $Enums.DealerStatus
    users?: IntFieldUpdateOperationsInput | number
    last?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAssetCreateInput = {
    id?: string
    name: string
    type: $Enums.FileType
    cat: $Enums.FileCategory
    vis: $Enums.FileVisibility
    url: string
    desc?: string | null
    size?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAssetUncheckedCreateInput = {
    id?: string
    name: string
    type: $Enums.FileType
    cat: $Enums.FileCategory
    vis: $Enums.FileVisibility
    url: string
    desc?: string | null
    size?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAssetUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    cat?: EnumFileCategoryFieldUpdateOperationsInput | $Enums.FileCategory
    vis?: EnumFileVisibilityFieldUpdateOperationsInput | $Enums.FileVisibility
    url?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAssetUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    cat?: EnumFileCategoryFieldUpdateOperationsInput | $Enums.FileCategory
    vis?: EnumFileVisibilityFieldUpdateOperationsInput | $Enums.FileVisibility
    url?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAssetCreateManyInput = {
    id?: string
    name: string
    type: $Enums.FileType
    cat: $Enums.FileCategory
    vis: $Enums.FileVisibility
    url: string
    desc?: string | null
    size?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileAssetUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    cat?: EnumFileCategoryFieldUpdateOperationsInput | $Enums.FileCategory
    vis?: EnumFileVisibilityFieldUpdateOperationsInput | $Enums.FileVisibility
    url?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileAssetUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    cat?: EnumFileCategoryFieldUpdateOperationsInput | $Enums.FileCategory
    vis?: EnumFileVisibilityFieldUpdateOperationsInput | $Enums.FileVisibility
    url?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    code?: string | null
    variant?: string | null
    short?: string | null
    long?: string | null
    bullets?: string | null
    nij?: string | null
    thickness?: string | null
    vlt?: string | null
    impact?: string | null
    images?: ProductCreateimagesInput | string[]
    datasheet?: string | null
    slug: string
    metaTitle?: string | null
    metaDesc?: string | null
    status?: $Enums.ProductStatus
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    code?: string | null
    variant?: string | null
    short?: string | null
    long?: string | null
    bullets?: string | null
    nij?: string | null
    thickness?: string | null
    vlt?: string | null
    impact?: string | null
    images?: ProductCreateimagesInput | string[]
    datasheet?: string | null
    slug: string
    metaTitle?: string | null
    metaDesc?: string | null
    status?: $Enums.ProductStatus
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    short?: NullableStringFieldUpdateOperationsInput | string | null
    long?: NullableStringFieldUpdateOperationsInput | string | null
    bullets?: NullableStringFieldUpdateOperationsInput | string | null
    nij?: NullableStringFieldUpdateOperationsInput | string | null
    thickness?: NullableStringFieldUpdateOperationsInput | string | null
    vlt?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    datasheet?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    short?: NullableStringFieldUpdateOperationsInput | string | null
    long?: NullableStringFieldUpdateOperationsInput | string | null
    bullets?: NullableStringFieldUpdateOperationsInput | string | null
    nij?: NullableStringFieldUpdateOperationsInput | string | null
    thickness?: NullableStringFieldUpdateOperationsInput | string | null
    vlt?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    datasheet?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    code?: string | null
    variant?: string | null
    short?: string | null
    long?: string | null
    bullets?: string | null
    nij?: string | null
    thickness?: string | null
    vlt?: string | null
    impact?: string | null
    images?: ProductCreateimagesInput | string[]
    datasheet?: string | null
    slug: string
    metaTitle?: string | null
    metaDesc?: string | null
    status?: $Enums.ProductStatus
    updatedAt?: Date | string
    createdAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    short?: NullableStringFieldUpdateOperationsInput | string | null
    long?: NullableStringFieldUpdateOperationsInput | string | null
    bullets?: NullableStringFieldUpdateOperationsInput | string | null
    nij?: NullableStringFieldUpdateOperationsInput | string | null
    thickness?: NullableStringFieldUpdateOperationsInput | string | null
    vlt?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    datasheet?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    variant?: NullableStringFieldUpdateOperationsInput | string | null
    short?: NullableStringFieldUpdateOperationsInput | string | null
    long?: NullableStringFieldUpdateOperationsInput | string | null
    bullets?: NullableStringFieldUpdateOperationsInput | string | null
    nij?: NullableStringFieldUpdateOperationsInput | string | null
    thickness?: NullableStringFieldUpdateOperationsInput | string | null
    vlt?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableStringFieldUpdateOperationsInput | string | null
    images?: ProductUpdateimagesInput | string[]
    datasheet?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDesc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealerUploadCreateInput = {
    id?: string
    userId: string
    email: string
    name: string
    category: string
    description?: string | null
    status?: $Enums.DealerUploadStatus
    reviewerId?: string | null
    reviewNote?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type DealerUploadUncheckedCreateInput = {
    id?: string
    userId: string
    email: string
    name: string
    category: string
    description?: string | null
    status?: $Enums.DealerUploadStatus
    reviewerId?: string | null
    reviewNote?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type DealerUploadUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDealerUploadStatusFieldUpdateOperationsInput | $Enums.DealerUploadStatus
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DealerUploadUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDealerUploadStatusFieldUpdateOperationsInput | $Enums.DealerUploadStatus
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DealerUploadCreateManyInput = {
    id?: string
    userId: string
    email: string
    name: string
    category: string
    description?: string | null
    status?: $Enums.DealerUploadStatus
    reviewerId?: string | null
    reviewNote?: string | null
    createdAt?: Date | string
    reviewedAt?: Date | string | null
  }

  export type DealerUploadUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDealerUploadStatusFieldUpdateOperationsInput | $Enums.DealerUploadStatus
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DealerUploadUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDealerUploadStatusFieldUpdateOperationsInput | $Enums.DealerUploadStatus
    reviewerId?: NullableStringFieldUpdateOperationsInput | string | null
    reviewNote?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrainingEventCreateInput = {
    id?: string
    title: string
    datetime: Date | string
    mode: $Enums.TrainingMode
    location?: string | null
    desc?: string | null
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingEventUncheckedCreateInput = {
    id?: string
    title: string
    datetime: Date | string
    mode: $Enums.TrainingMode
    location?: string | null
    desc?: string | null
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingEventUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    mode?: EnumTrainingModeFieldUpdateOperationsInput | $Enums.TrainingMode
    location?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingEventUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    mode?: EnumTrainingModeFieldUpdateOperationsInput | $Enums.TrainingMode
    location?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingEventCreateManyInput = {
    id?: string
    title: string
    datetime: Date | string
    mode: $Enums.TrainingMode
    location?: string | null
    desc?: string | null
    status?: $Enums.TrainingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingEventUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    mode?: EnumTrainingModeFieldUpdateOperationsInput | $Enums.TrainingMode
    location?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingEventUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    datetime?: DateTimeFieldUpdateOperationsInput | Date | string
    mode?: EnumTrainingModeFieldUpdateOperationsInput | $Enums.TrainingMode
    location?: NullableStringFieldUpdateOperationsInput | string | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTrainingStatusFieldUpdateOperationsInput | $Enums.TrainingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingRegistrationCreateInput = {
    id?: string
    eventId: string
    userId: string
    note?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type TrainingRegistrationUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    note?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type TrainingRegistrationUpdateInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingRegistrationUncheckedUpdateInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingRegistrationCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    note?: string | null
    status?: string
    createdAt?: Date | string
  }

  export type TrainingRegistrationUpdateManyMutationInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingRegistrationUncheckedUpdateManyInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    has?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type UploadAssetListRelationFilter = {
    every?: UploadAssetWhereInput
    some?: UploadAssetWhereInput
    none?: UploadAssetWhereInput
  }

  export type PageListRelationFilter = {
    every?: PageWhereInput
    some?: PageWhereInput
    none?: PageWhereInput
  }

  export type AuditEventListRelationFilter = {
    every?: AuditEventWhereInput
    some?: AuditEventWhereInput
    none?: AuditEventWhereInput
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UploadAssetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    roles?: SortOrder
    profile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    refreshToken?: SortOrder
    userAgent?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
    revokedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumPageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PageStatus | EnumPageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PageStatus[] | ListEnumPageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PageStatus[] | ListEnumPageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPageStatusFilter<$PrismaModel> | $Enums.PageStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    body?: SortOrder
    status?: SortOrder
    meta?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    body?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    body?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    updatedById?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PageStatus | EnumPageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PageStatus[] | ListEnumPageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PageStatus[] | ListEnumPageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPageStatusWithAggregatesFilter<$PrismaModel> | $Enums.PageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPageStatusFilter<$PrismaModel>
    _max?: NestedEnumPageStatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UploadAssetCountOrderByAggregateInput = {
    id?: SortOrder
    objectKey?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    publicUrl?: SortOrder
    context?: SortOrder
    uploaderId?: SortOrder
    createdAt?: SortOrder
  }

  export type UploadAssetAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type UploadAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    objectKey?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    publicUrl?: SortOrder
    context?: SortOrder
    uploaderId?: SortOrder
    createdAt?: SortOrder
  }

  export type UploadAssetMinOrderByAggregateInput = {
    id?: SortOrder
    objectKey?: SortOrder
    contentType?: SortOrder
    size?: SortOrder
    publicUrl?: SortOrder
    context?: SortOrder
    uploaderId?: SortOrder
    createdAt?: SortOrder
  }

  export type UploadAssetSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumInstallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallStatus | EnumInstallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallStatus[] | ListEnumInstallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallStatus[] | ListEnumInstallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallStatusFilter<$PrismaModel> | $Enums.InstallStatus
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstallationCountOrderByAggregateInput = {
    id?: SortOrder
    dealerId?: SortOrder
    siteName?: SortOrder
    address?: SortOrder
    customerInfo?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallationMaxOrderByAggregateInput = {
    id?: SortOrder
    dealerId?: SortOrder
    siteName?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstallationMinOrderByAggregateInput = {
    id?: SortOrder
    dealerId?: SortOrder
    siteName?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInstallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallStatus | EnumInstallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallStatus[] | ListEnumInstallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallStatus[] | ListEnumInstallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstallStatusFilter<$PrismaModel>
    _max?: NestedEnumInstallStatusFilter<$PrismaModel>
  }

  export type InstallationRelationFilter = {
    is?: InstallationWhereInput
    isNot?: InstallationWhereInput
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    installationId?: SortOrder
    reportType?: SortOrder
    notes?: SortOrder
    uploadObjectKey?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    installationId?: SortOrder
    reportType?: SortOrder
    notes?: SortOrder
    uploadObjectKey?: SortOrder
    createdAt?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    installationId?: SortOrder
    reportType?: SortOrder
    notes?: SortOrder
    uploadObjectKey?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    meta?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditEventMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    target?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLeadTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadType | EnumLeadTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeadType[] | ListEnumLeadTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadType[] | ListEnumLeadTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadTypeFilter<$PrismaModel> | $Enums.LeadType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    country?: SortOrder
    type?: SortOrder
    message?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    owner?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    country?: SortOrder
    type?: SortOrder
    message?: SortOrder
    status?: SortOrder
    owner?: SortOrder
    createdAt?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    country?: SortOrder
    type?: SortOrder
    message?: SortOrder
    status?: SortOrder
    owner?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumLeadTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadType | EnumLeadTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeadType[] | ListEnumLeadTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadType[] | ListEnumLeadTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeadType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadTypeFilter<$PrismaModel>
    _max?: NestedEnumLeadTypeFilter<$PrismaModel>
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type EnumDealerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DealerStatus | EnumDealerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealerStatus[] | ListEnumDealerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealerStatus[] | ListEnumDealerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealerStatusFilter<$PrismaModel> | $Enums.DealerStatus
  }

  export type DealerCountOrderByAggregateInput = {
    id?: SortOrder
    org?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    region?: SortOrder
    status?: SortOrder
    users?: SortOrder
    last?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealerAvgOrderByAggregateInput = {
    users?: SortOrder
  }

  export type DealerMaxOrderByAggregateInput = {
    id?: SortOrder
    org?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    region?: SortOrder
    status?: SortOrder
    users?: SortOrder
    last?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealerMinOrderByAggregateInput = {
    id?: SortOrder
    org?: SortOrder
    contactName?: SortOrder
    contactEmail?: SortOrder
    region?: SortOrder
    status?: SortOrder
    users?: SortOrder
    last?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealerSumOrderByAggregateInput = {
    users?: SortOrder
  }

  export type EnumDealerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealerStatus | EnumDealerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealerStatus[] | ListEnumDealerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealerStatus[] | ListEnumDealerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealerStatusWithAggregatesFilter<$PrismaModel> | $Enums.DealerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealerStatusFilter<$PrismaModel>
    _max?: NestedEnumDealerStatusFilter<$PrismaModel>
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type EnumFileCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FileCategory | EnumFileCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FileCategory[] | ListEnumFileCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileCategory[] | ListEnumFileCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFileCategoryFilter<$PrismaModel> | $Enums.FileCategory
  }

  export type EnumFileVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.FileVisibility | EnumFileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.FileVisibility[] | ListEnumFileVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileVisibility[] | ListEnumFileVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumFileVisibilityFilter<$PrismaModel> | $Enums.FileVisibility
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type FileAssetCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cat?: SortOrder
    vis?: SortOrder
    url?: SortOrder
    desc?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileAssetAvgOrderByAggregateInput = {
    size?: SortOrder
  }

  export type FileAssetMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cat?: SortOrder
    vis?: SortOrder
    url?: SortOrder
    desc?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileAssetMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    cat?: SortOrder
    vis?: SortOrder
    url?: SortOrder
    desc?: SortOrder
    size?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileAssetSumOrderByAggregateInput = {
    size?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type EnumFileCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileCategory | EnumFileCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FileCategory[] | ListEnumFileCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileCategory[] | ListEnumFileCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFileCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FileCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileCategoryFilter<$PrismaModel>
    _max?: NestedEnumFileCategoryFilter<$PrismaModel>
  }

  export type EnumFileVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileVisibility | EnumFileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.FileVisibility[] | ListEnumFileVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileVisibility[] | ListEnumFileVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumFileVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.FileVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileVisibilityFilter<$PrismaModel>
    _max?: NestedEnumFileVisibilityFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type EnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    variant?: SortOrder
    short?: SortOrder
    long?: SortOrder
    bullets?: SortOrder
    nij?: SortOrder
    thickness?: SortOrder
    vlt?: SortOrder
    impact?: SortOrder
    images?: SortOrder
    datasheet?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrder
    metaDesc?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    variant?: SortOrder
    short?: SortOrder
    long?: SortOrder
    bullets?: SortOrder
    nij?: SortOrder
    thickness?: SortOrder
    vlt?: SortOrder
    impact?: SortOrder
    datasheet?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrder
    metaDesc?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    code?: SortOrder
    variant?: SortOrder
    short?: SortOrder
    long?: SortOrder
    bullets?: SortOrder
    nij?: SortOrder
    thickness?: SortOrder
    vlt?: SortOrder
    impact?: SortOrder
    datasheet?: SortOrder
    slug?: SortOrder
    metaTitle?: SortOrder
    metaDesc?: SortOrder
    status?: SortOrder
    updatedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type EnumDealerUploadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DealerUploadStatus | EnumDealerUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealerUploadStatus[] | ListEnumDealerUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealerUploadStatus[] | ListEnumDealerUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealerUploadStatusFilter<$PrismaModel> | $Enums.DealerUploadStatus
  }

  export type DealerUploadCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrder
    reviewNote?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type DealerUploadMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrder
    reviewNote?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type DealerUploadMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    category?: SortOrder
    description?: SortOrder
    status?: SortOrder
    reviewerId?: SortOrder
    reviewNote?: SortOrder
    createdAt?: SortOrder
    reviewedAt?: SortOrder
  }

  export type EnumDealerUploadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealerUploadStatus | EnumDealerUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealerUploadStatus[] | ListEnumDealerUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealerUploadStatus[] | ListEnumDealerUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealerUploadStatusWithAggregatesFilter<$PrismaModel> | $Enums.DealerUploadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealerUploadStatusFilter<$PrismaModel>
    _max?: NestedEnumDealerUploadStatusFilter<$PrismaModel>
  }

  export type EnumTrainingModeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingMode | EnumTrainingModeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingMode[] | ListEnumTrainingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingMode[] | ListEnumTrainingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingModeFilter<$PrismaModel> | $Enums.TrainingMode
  }

  export type EnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type TrainingEventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    datetime?: SortOrder
    mode?: SortOrder
    location?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingEventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    datetime?: SortOrder
    mode?: SortOrder
    location?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingEventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    datetime?: SortOrder
    mode?: SortOrder
    location?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTrainingModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingMode | EnumTrainingModeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingMode[] | ListEnumTrainingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingMode[] | ListEnumTrainingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingModeWithAggregatesFilter<$PrismaModel> | $Enums.TrainingMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingModeFilter<$PrismaModel>
    _max?: NestedEnumTrainingModeFilter<$PrismaModel>
  }

  export type EnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type TrainingRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type TrainingRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    note?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type UserCreaterolesInput = {
    set: $Enums.Role[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UploadAssetCreateNestedManyWithoutUploaderInput = {
    create?: XOR<UploadAssetCreateWithoutUploaderInput, UploadAssetUncheckedCreateWithoutUploaderInput> | UploadAssetCreateWithoutUploaderInput[] | UploadAssetUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: UploadAssetCreateOrConnectWithoutUploaderInput | UploadAssetCreateOrConnectWithoutUploaderInput[]
    createMany?: UploadAssetCreateManyUploaderInputEnvelope
    connect?: UploadAssetWhereUniqueInput | UploadAssetWhereUniqueInput[]
  }

  export type PageCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PageCreateWithoutCreatedByInput, PageUncheckedCreateWithoutCreatedByInput> | PageCreateWithoutCreatedByInput[] | PageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatedByInput | PageCreateOrConnectWithoutCreatedByInput[]
    createMany?: PageCreateManyCreatedByInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PageCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<PageCreateWithoutUpdatedByInput, PageUncheckedCreateWithoutUpdatedByInput> | PageCreateWithoutUpdatedByInput[] | PageUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PageCreateOrConnectWithoutUpdatedByInput | PageCreateOrConnectWithoutUpdatedByInput[]
    createMany?: PageCreateManyUpdatedByInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type AuditEventCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditEventCreateWithoutActorInput, AuditEventUncheckedCreateWithoutActorInput> | AuditEventCreateWithoutActorInput[] | AuditEventUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorInput | AuditEventCreateOrConnectWithoutActorInput[]
    createMany?: AuditEventCreateManyActorInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type UploadAssetUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<UploadAssetCreateWithoutUploaderInput, UploadAssetUncheckedCreateWithoutUploaderInput> | UploadAssetCreateWithoutUploaderInput[] | UploadAssetUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: UploadAssetCreateOrConnectWithoutUploaderInput | UploadAssetCreateOrConnectWithoutUploaderInput[]
    createMany?: UploadAssetCreateManyUploaderInputEnvelope
    connect?: UploadAssetWhereUniqueInput | UploadAssetWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PageCreateWithoutCreatedByInput, PageUncheckedCreateWithoutCreatedByInput> | PageCreateWithoutCreatedByInput[] | PageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatedByInput | PageCreateOrConnectWithoutCreatedByInput[]
    createMany?: PageCreateManyCreatedByInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type PageUncheckedCreateNestedManyWithoutUpdatedByInput = {
    create?: XOR<PageCreateWithoutUpdatedByInput, PageUncheckedCreateWithoutUpdatedByInput> | PageCreateWithoutUpdatedByInput[] | PageUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PageCreateOrConnectWithoutUpdatedByInput | PageCreateOrConnectWithoutUpdatedByInput[]
    createMany?: PageCreateManyUpdatedByInputEnvelope
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
  }

  export type AuditEventUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AuditEventCreateWithoutActorInput, AuditEventUncheckedCreateWithoutActorInput> | AuditEventCreateWithoutActorInput[] | AuditEventUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorInput | AuditEventCreateOrConnectWithoutActorInput[]
    createMany?: AuditEventCreateManyActorInputEnvelope
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type UserUpdaterolesInput = {
    set?: $Enums.Role[]
    push?: $Enums.Role | $Enums.Role[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UploadAssetUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<UploadAssetCreateWithoutUploaderInput, UploadAssetUncheckedCreateWithoutUploaderInput> | UploadAssetCreateWithoutUploaderInput[] | UploadAssetUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: UploadAssetCreateOrConnectWithoutUploaderInput | UploadAssetCreateOrConnectWithoutUploaderInput[]
    upsert?: UploadAssetUpsertWithWhereUniqueWithoutUploaderInput | UploadAssetUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: UploadAssetCreateManyUploaderInputEnvelope
    set?: UploadAssetWhereUniqueInput | UploadAssetWhereUniqueInput[]
    disconnect?: UploadAssetWhereUniqueInput | UploadAssetWhereUniqueInput[]
    delete?: UploadAssetWhereUniqueInput | UploadAssetWhereUniqueInput[]
    connect?: UploadAssetWhereUniqueInput | UploadAssetWhereUniqueInput[]
    update?: UploadAssetUpdateWithWhereUniqueWithoutUploaderInput | UploadAssetUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: UploadAssetUpdateManyWithWhereWithoutUploaderInput | UploadAssetUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: UploadAssetScalarWhereInput | UploadAssetScalarWhereInput[]
  }

  export type PageUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PageCreateWithoutCreatedByInput, PageUncheckedCreateWithoutCreatedByInput> | PageCreateWithoutCreatedByInput[] | PageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatedByInput | PageCreateOrConnectWithoutCreatedByInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutCreatedByInput | PageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PageCreateManyCreatedByInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutCreatedByInput | PageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PageUpdateManyWithWhereWithoutCreatedByInput | PageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PageUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<PageCreateWithoutUpdatedByInput, PageUncheckedCreateWithoutUpdatedByInput> | PageCreateWithoutUpdatedByInput[] | PageUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PageCreateOrConnectWithoutUpdatedByInput | PageCreateOrConnectWithoutUpdatedByInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutUpdatedByInput | PageUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: PageCreateManyUpdatedByInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutUpdatedByInput | PageUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: PageUpdateManyWithWhereWithoutUpdatedByInput | PageUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type AuditEventUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditEventCreateWithoutActorInput, AuditEventUncheckedCreateWithoutActorInput> | AuditEventCreateWithoutActorInput[] | AuditEventUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorInput | AuditEventCreateOrConnectWithoutActorInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutActorInput | AuditEventUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditEventCreateManyActorInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutActorInput | AuditEventUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutActorInput | AuditEventUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type UploadAssetUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<UploadAssetCreateWithoutUploaderInput, UploadAssetUncheckedCreateWithoutUploaderInput> | UploadAssetCreateWithoutUploaderInput[] | UploadAssetUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: UploadAssetCreateOrConnectWithoutUploaderInput | UploadAssetCreateOrConnectWithoutUploaderInput[]
    upsert?: UploadAssetUpsertWithWhereUniqueWithoutUploaderInput | UploadAssetUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: UploadAssetCreateManyUploaderInputEnvelope
    set?: UploadAssetWhereUniqueInput | UploadAssetWhereUniqueInput[]
    disconnect?: UploadAssetWhereUniqueInput | UploadAssetWhereUniqueInput[]
    delete?: UploadAssetWhereUniqueInput | UploadAssetWhereUniqueInput[]
    connect?: UploadAssetWhereUniqueInput | UploadAssetWhereUniqueInput[]
    update?: UploadAssetUpdateWithWhereUniqueWithoutUploaderInput | UploadAssetUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: UploadAssetUpdateManyWithWhereWithoutUploaderInput | UploadAssetUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: UploadAssetScalarWhereInput | UploadAssetScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PageCreateWithoutCreatedByInput, PageUncheckedCreateWithoutCreatedByInput> | PageCreateWithoutCreatedByInput[] | PageUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PageCreateOrConnectWithoutCreatedByInput | PageCreateOrConnectWithoutCreatedByInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutCreatedByInput | PageUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PageCreateManyCreatedByInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutCreatedByInput | PageUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PageUpdateManyWithWhereWithoutCreatedByInput | PageUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type PageUncheckedUpdateManyWithoutUpdatedByNestedInput = {
    create?: XOR<PageCreateWithoutUpdatedByInput, PageUncheckedCreateWithoutUpdatedByInput> | PageCreateWithoutUpdatedByInput[] | PageUncheckedCreateWithoutUpdatedByInput[]
    connectOrCreate?: PageCreateOrConnectWithoutUpdatedByInput | PageCreateOrConnectWithoutUpdatedByInput[]
    upsert?: PageUpsertWithWhereUniqueWithoutUpdatedByInput | PageUpsertWithWhereUniqueWithoutUpdatedByInput[]
    createMany?: PageCreateManyUpdatedByInputEnvelope
    set?: PageWhereUniqueInput | PageWhereUniqueInput[]
    disconnect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    delete?: PageWhereUniqueInput | PageWhereUniqueInput[]
    connect?: PageWhereUniqueInput | PageWhereUniqueInput[]
    update?: PageUpdateWithWhereUniqueWithoutUpdatedByInput | PageUpdateWithWhereUniqueWithoutUpdatedByInput[]
    updateMany?: PageUpdateManyWithWhereWithoutUpdatedByInput | PageUpdateManyWithWhereWithoutUpdatedByInput[]
    deleteMany?: PageScalarWhereInput | PageScalarWhereInput[]
  }

  export type AuditEventUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AuditEventCreateWithoutActorInput, AuditEventUncheckedCreateWithoutActorInput> | AuditEventCreateWithoutActorInput[] | AuditEventUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AuditEventCreateOrConnectWithoutActorInput | AuditEventCreateOrConnectWithoutActorInput[]
    upsert?: AuditEventUpsertWithWhereUniqueWithoutActorInput | AuditEventUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AuditEventCreateManyActorInputEnvelope
    set?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    disconnect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    delete?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    connect?: AuditEventWhereUniqueInput | AuditEventWhereUniqueInput[]
    update?: AuditEventUpdateWithWhereUniqueWithoutActorInput | AuditEventUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AuditEventUpdateManyWithWhereWithoutActorInput | AuditEventUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutPagesCreatedInput = {
    create?: XOR<UserCreateWithoutPagesCreatedInput, UserUncheckedCreateWithoutPagesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPagesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPagesUpdatedInput = {
    create?: XOR<UserCreateWithoutPagesUpdatedInput, UserUncheckedCreateWithoutPagesUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPagesUpdatedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPageStatusFieldUpdateOperationsInput = {
    set?: $Enums.PageStatus
  }

  export type UserUpdateOneRequiredWithoutPagesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutPagesCreatedInput, UserUncheckedCreateWithoutPagesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPagesCreatedInput
    upsert?: UserUpsertWithoutPagesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPagesCreatedInput, UserUpdateWithoutPagesCreatedInput>, UserUncheckedUpdateWithoutPagesCreatedInput>
  }

  export type UserUpdateOneWithoutPagesUpdatedNestedInput = {
    create?: XOR<UserCreateWithoutPagesUpdatedInput, UserUncheckedCreateWithoutPagesUpdatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPagesUpdatedInput
    upsert?: UserUpsertWithoutPagesUpdatedInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPagesUpdatedInput, UserUpdateWithoutPagesUpdatedInput>, UserUncheckedUpdateWithoutPagesUpdatedInput>
  }

  export type UserCreateNestedOneWithoutUploadsInput = {
    create?: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadsInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutUploadsNestedInput = {
    create?: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUploadsInput
    upsert?: UserUpsertWithoutUploadsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUploadsInput, UserUpdateWithoutUploadsInput>, UserUncheckedUpdateWithoutUploadsInput>
  }

  export type ReportCreateNestedManyWithoutInstallationInput = {
    create?: XOR<ReportCreateWithoutInstallationInput, ReportUncheckedCreateWithoutInstallationInput> | ReportCreateWithoutInstallationInput[] | ReportUncheckedCreateWithoutInstallationInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutInstallationInput | ReportCreateOrConnectWithoutInstallationInput[]
    createMany?: ReportCreateManyInstallationInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutInstallationInput = {
    create?: XOR<ReportCreateWithoutInstallationInput, ReportUncheckedCreateWithoutInstallationInput> | ReportCreateWithoutInstallationInput[] | ReportUncheckedCreateWithoutInstallationInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutInstallationInput | ReportCreateOrConnectWithoutInstallationInput[]
    createMany?: ReportCreateManyInstallationInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type EnumInstallStatusFieldUpdateOperationsInput = {
    set?: $Enums.InstallStatus
  }

  export type ReportUpdateManyWithoutInstallationNestedInput = {
    create?: XOR<ReportCreateWithoutInstallationInput, ReportUncheckedCreateWithoutInstallationInput> | ReportCreateWithoutInstallationInput[] | ReportUncheckedCreateWithoutInstallationInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutInstallationInput | ReportCreateOrConnectWithoutInstallationInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutInstallationInput | ReportUpsertWithWhereUniqueWithoutInstallationInput[]
    createMany?: ReportCreateManyInstallationInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutInstallationInput | ReportUpdateWithWhereUniqueWithoutInstallationInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutInstallationInput | ReportUpdateManyWithWhereWithoutInstallationInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutInstallationNestedInput = {
    create?: XOR<ReportCreateWithoutInstallationInput, ReportUncheckedCreateWithoutInstallationInput> | ReportCreateWithoutInstallationInput[] | ReportUncheckedCreateWithoutInstallationInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutInstallationInput | ReportCreateOrConnectWithoutInstallationInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutInstallationInput | ReportUpsertWithWhereUniqueWithoutInstallationInput[]
    createMany?: ReportCreateManyInstallationInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutInstallationInput | ReportUpdateWithWhereUniqueWithoutInstallationInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutInstallationInput | ReportUpdateManyWithWhereWithoutInstallationInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type InstallationCreateNestedOneWithoutReportsInput = {
    create?: XOR<InstallationCreateWithoutReportsInput, InstallationUncheckedCreateWithoutReportsInput>
    connectOrCreate?: InstallationCreateOrConnectWithoutReportsInput
    connect?: InstallationWhereUniqueInput
  }

  export type InstallationUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<InstallationCreateWithoutReportsInput, InstallationUncheckedCreateWithoutReportsInput>
    connectOrCreate?: InstallationCreateOrConnectWithoutReportsInput
    upsert?: InstallationUpsertWithoutReportsInput
    connect?: InstallationWhereUniqueInput
    update?: XOR<XOR<InstallationUpdateToOneWithWhereWithoutReportsInput, InstallationUpdateWithoutReportsInput>, InstallationUncheckedUpdateWithoutReportsInput>
  }

  export type UserCreateNestedOneWithoutAuditEventsInput = {
    create?: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditEventsNestedInput = {
    create?: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditEventsInput
    upsert?: UserUpsertWithoutAuditEventsInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditEventsInput, UserUpdateWithoutAuditEventsInput>, UserUncheckedUpdateWithoutAuditEventsInput>
  }

  export type LeadCreatetagsInput = {
    set: string[]
  }

  export type EnumLeadTypeFieldUpdateOperationsInput = {
    set?: $Enums.LeadType
  }

  export type LeadUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type EnumDealerStatusFieldUpdateOperationsInput = {
    set?: $Enums.DealerStatus
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type EnumFileCategoryFieldUpdateOperationsInput = {
    set?: $Enums.FileCategory
  }

  export type EnumFileVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.FileVisibility
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type ProductCreateimagesInput = {
    set: string[]
  }

  export type ProductUpdateimagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductStatus
  }

  export type EnumDealerUploadStatusFieldUpdateOperationsInput = {
    set?: $Enums.DealerUploadStatus
  }

  export type EnumTrainingModeFieldUpdateOperationsInput = {
    set?: $Enums.TrainingMode
  }

  export type EnumTrainingStatusFieldUpdateOperationsInput = {
    set?: $Enums.TrainingStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    isSet?: boolean
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumPageStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PageStatus | EnumPageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PageStatus[] | ListEnumPageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PageStatus[] | ListEnumPageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPageStatusFilter<$PrismaModel> | $Enums.PageStatus
  }

  export type NestedEnumPageStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PageStatus | EnumPageStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PageStatus[] | ListEnumPageStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PageStatus[] | ListEnumPageStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPageStatusWithAggregatesFilter<$PrismaModel> | $Enums.PageStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPageStatusFilter<$PrismaModel>
    _max?: NestedEnumPageStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumInstallStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallStatus | EnumInstallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallStatus[] | ListEnumInstallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallStatus[] | ListEnumInstallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallStatusFilter<$PrismaModel> | $Enums.InstallStatus
  }

  export type NestedEnumInstallStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InstallStatus | EnumInstallStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InstallStatus[] | ListEnumInstallStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InstallStatus[] | ListEnumInstallStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInstallStatusWithAggregatesFilter<$PrismaModel> | $Enums.InstallStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInstallStatusFilter<$PrismaModel>
    _max?: NestedEnumInstallStatusFilter<$PrismaModel>
  }

  export type NestedEnumLeadTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadType | EnumLeadTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeadType[] | ListEnumLeadTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadType[] | ListEnumLeadTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadTypeFilter<$PrismaModel> | $Enums.LeadType
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedEnumLeadTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadType | EnumLeadTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LeadType[] | ListEnumLeadTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadType[] | ListEnumLeadTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadTypeWithAggregatesFilter<$PrismaModel> | $Enums.LeadType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadTypeFilter<$PrismaModel>
    _max?: NestedEnumLeadTypeFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedEnumDealerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DealerStatus | EnumDealerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealerStatus[] | ListEnumDealerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealerStatus[] | ListEnumDealerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealerStatusFilter<$PrismaModel> | $Enums.DealerStatus
  }

  export type NestedEnumDealerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealerStatus | EnumDealerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealerStatus[] | ListEnumDealerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealerStatus[] | ListEnumDealerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealerStatusWithAggregatesFilter<$PrismaModel> | $Enums.DealerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealerStatusFilter<$PrismaModel>
    _max?: NestedEnumDealerStatusFilter<$PrismaModel>
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedEnumFileCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.FileCategory | EnumFileCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FileCategory[] | ListEnumFileCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileCategory[] | ListEnumFileCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFileCategoryFilter<$PrismaModel> | $Enums.FileCategory
  }

  export type NestedEnumFileVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.FileVisibility | EnumFileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.FileVisibility[] | ListEnumFileVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileVisibility[] | ListEnumFileVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumFileVisibilityFilter<$PrismaModel> | $Enums.FileVisibility
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedEnumFileCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileCategory | EnumFileCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.FileCategory[] | ListEnumFileCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileCategory[] | ListEnumFileCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumFileCategoryWithAggregatesFilter<$PrismaModel> | $Enums.FileCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileCategoryFilter<$PrismaModel>
    _max?: NestedEnumFileCategoryFilter<$PrismaModel>
  }

  export type NestedEnumFileVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileVisibility | EnumFileVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.FileVisibility[] | ListEnumFileVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileVisibility[] | ListEnumFileVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumFileVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.FileVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileVisibilityFilter<$PrismaModel>
    _max?: NestedEnumFileVisibilityFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type NestedEnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type NestedEnumDealerUploadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DealerUploadStatus | EnumDealerUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealerUploadStatus[] | ListEnumDealerUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealerUploadStatus[] | ListEnumDealerUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealerUploadStatusFilter<$PrismaModel> | $Enums.DealerUploadStatus
  }

  export type NestedEnumDealerUploadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DealerUploadStatus | EnumDealerUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DealerUploadStatus[] | ListEnumDealerUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DealerUploadStatus[] | ListEnumDealerUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDealerUploadStatusWithAggregatesFilter<$PrismaModel> | $Enums.DealerUploadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDealerUploadStatusFilter<$PrismaModel>
    _max?: NestedEnumDealerUploadStatusFilter<$PrismaModel>
  }

  export type NestedEnumTrainingModeFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingMode | EnumTrainingModeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingMode[] | ListEnumTrainingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingMode[] | ListEnumTrainingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingModeFilter<$PrismaModel> | $Enums.TrainingMode
  }

  export type NestedEnumTrainingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusFilter<$PrismaModel> | $Enums.TrainingStatus
  }

  export type NestedEnumTrainingModeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingMode | EnumTrainingModeFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingMode[] | ListEnumTrainingModeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingMode[] | ListEnumTrainingModeFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingModeWithAggregatesFilter<$PrismaModel> | $Enums.TrainingMode
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingModeFilter<$PrismaModel>
    _max?: NestedEnumTrainingModeFilter<$PrismaModel>
  }

  export type NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingStatus | EnumTrainingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingStatus[] | ListEnumTrainingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingStatusFilter<$PrismaModel>
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ip?: string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ip?: string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type UploadAssetCreateWithoutUploaderInput = {
    id?: string
    objectKey: string
    contentType: string
    size: number
    publicUrl?: string | null
    context?: string | null
    createdAt?: Date | string
  }

  export type UploadAssetUncheckedCreateWithoutUploaderInput = {
    id?: string
    objectKey: string
    contentType: string
    size: number
    publicUrl?: string | null
    context?: string | null
    createdAt?: Date | string
  }

  export type UploadAssetCreateOrConnectWithoutUploaderInput = {
    where: UploadAssetWhereUniqueInput
    create: XOR<UploadAssetCreateWithoutUploaderInput, UploadAssetUncheckedCreateWithoutUploaderInput>
  }

  export type UploadAssetCreateManyUploaderInputEnvelope = {
    data: UploadAssetCreateManyUploaderInput | UploadAssetCreateManyUploaderInput[]
  }

  export type PageCreateWithoutCreatedByInput = {
    id?: string
    title: string
    slug: string
    body: string
    status?: $Enums.PageStatus
    meta?: InputJsonValue | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    updatedBy?: UserCreateNestedOneWithoutPagesUpdatedInput
  }

  export type PageUncheckedCreateWithoutCreatedByInput = {
    id?: string
    title: string
    slug: string
    body: string
    status?: $Enums.PageStatus
    meta?: InputJsonValue | null
    updatedById?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageCreateOrConnectWithoutCreatedByInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutCreatedByInput, PageUncheckedCreateWithoutCreatedByInput>
  }

  export type PageCreateManyCreatedByInputEnvelope = {
    data: PageCreateManyCreatedByInput | PageCreateManyCreatedByInput[]
  }

  export type PageCreateWithoutUpdatedByInput = {
    id?: string
    title: string
    slug: string
    body: string
    status?: $Enums.PageStatus
    meta?: InputJsonValue | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutPagesCreatedInput
  }

  export type PageUncheckedCreateWithoutUpdatedByInput = {
    id?: string
    title: string
    slug: string
    body: string
    status?: $Enums.PageStatus
    meta?: InputJsonValue | null
    createdById: string
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageCreateOrConnectWithoutUpdatedByInput = {
    where: PageWhereUniqueInput
    create: XOR<PageCreateWithoutUpdatedByInput, PageUncheckedCreateWithoutUpdatedByInput>
  }

  export type PageCreateManyUpdatedByInputEnvelope = {
    data: PageCreateManyUpdatedByInput | PageCreateManyUpdatedByInput[]
  }

  export type AuditEventCreateWithoutActorInput = {
    id?: string
    action: string
    target?: string | null
    meta?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type AuditEventUncheckedCreateWithoutActorInput = {
    id?: string
    action: string
    target?: string | null
    meta?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type AuditEventCreateOrConnectWithoutActorInput = {
    where: AuditEventWhereUniqueInput
    create: XOR<AuditEventCreateWithoutActorInput, AuditEventUncheckedCreateWithoutActorInput>
  }

  export type AuditEventCreateManyActorInputEnvelope = {
    data: AuditEventCreateManyActorInput | AuditEventCreateManyActorInput[]
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    refreshToken?: StringFilter<"Session"> | string
    userAgent?: StringNullableFilter<"Session"> | string | null
    ip?: StringNullableFilter<"Session"> | string | null
    createdAt?: DateTimeFilter<"Session"> | Date | string
    revokedAt?: DateTimeNullableFilter<"Session"> | Date | string | null
  }

  export type UploadAssetUpsertWithWhereUniqueWithoutUploaderInput = {
    where: UploadAssetWhereUniqueInput
    update: XOR<UploadAssetUpdateWithoutUploaderInput, UploadAssetUncheckedUpdateWithoutUploaderInput>
    create: XOR<UploadAssetCreateWithoutUploaderInput, UploadAssetUncheckedCreateWithoutUploaderInput>
  }

  export type UploadAssetUpdateWithWhereUniqueWithoutUploaderInput = {
    where: UploadAssetWhereUniqueInput
    data: XOR<UploadAssetUpdateWithoutUploaderInput, UploadAssetUncheckedUpdateWithoutUploaderInput>
  }

  export type UploadAssetUpdateManyWithWhereWithoutUploaderInput = {
    where: UploadAssetScalarWhereInput
    data: XOR<UploadAssetUpdateManyMutationInput, UploadAssetUncheckedUpdateManyWithoutUploaderInput>
  }

  export type UploadAssetScalarWhereInput = {
    AND?: UploadAssetScalarWhereInput | UploadAssetScalarWhereInput[]
    OR?: UploadAssetScalarWhereInput[]
    NOT?: UploadAssetScalarWhereInput | UploadAssetScalarWhereInput[]
    id?: StringFilter<"UploadAsset"> | string
    objectKey?: StringFilter<"UploadAsset"> | string
    contentType?: StringFilter<"UploadAsset"> | string
    size?: IntFilter<"UploadAsset"> | number
    publicUrl?: StringNullableFilter<"UploadAsset"> | string | null
    context?: StringNullableFilter<"UploadAsset"> | string | null
    uploaderId?: StringNullableFilter<"UploadAsset"> | string | null
    createdAt?: DateTimeFilter<"UploadAsset"> | Date | string
  }

  export type PageUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutCreatedByInput, PageUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PageCreateWithoutCreatedByInput, PageUncheckedCreateWithoutCreatedByInput>
  }

  export type PageUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutCreatedByInput, PageUncheckedUpdateWithoutCreatedByInput>
  }

  export type PageUpdateManyWithWhereWithoutCreatedByInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PageScalarWhereInput = {
    AND?: PageScalarWhereInput | PageScalarWhereInput[]
    OR?: PageScalarWhereInput[]
    NOT?: PageScalarWhereInput | PageScalarWhereInput[]
    id?: StringFilter<"Page"> | string
    title?: StringFilter<"Page"> | string
    slug?: StringFilter<"Page"> | string
    body?: StringFilter<"Page"> | string
    status?: EnumPageStatusFilter<"Page"> | $Enums.PageStatus
    meta?: JsonNullableFilter<"Page">
    createdById?: StringFilter<"Page"> | string
    updatedById?: StringNullableFilter<"Page"> | string | null
    publishedAt?: DateTimeNullableFilter<"Page"> | Date | string | null
    createdAt?: DateTimeFilter<"Page"> | Date | string
    updatedAt?: DateTimeFilter<"Page"> | Date | string
  }

  export type PageUpsertWithWhereUniqueWithoutUpdatedByInput = {
    where: PageWhereUniqueInput
    update: XOR<PageUpdateWithoutUpdatedByInput, PageUncheckedUpdateWithoutUpdatedByInput>
    create: XOR<PageCreateWithoutUpdatedByInput, PageUncheckedCreateWithoutUpdatedByInput>
  }

  export type PageUpdateWithWhereUniqueWithoutUpdatedByInput = {
    where: PageWhereUniqueInput
    data: XOR<PageUpdateWithoutUpdatedByInput, PageUncheckedUpdateWithoutUpdatedByInput>
  }

  export type PageUpdateManyWithWhereWithoutUpdatedByInput = {
    where: PageScalarWhereInput
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyWithoutUpdatedByInput>
  }

  export type AuditEventUpsertWithWhereUniqueWithoutActorInput = {
    where: AuditEventWhereUniqueInput
    update: XOR<AuditEventUpdateWithoutActorInput, AuditEventUncheckedUpdateWithoutActorInput>
    create: XOR<AuditEventCreateWithoutActorInput, AuditEventUncheckedCreateWithoutActorInput>
  }

  export type AuditEventUpdateWithWhereUniqueWithoutActorInput = {
    where: AuditEventWhereUniqueInput
    data: XOR<AuditEventUpdateWithoutActorInput, AuditEventUncheckedUpdateWithoutActorInput>
  }

  export type AuditEventUpdateManyWithWhereWithoutActorInput = {
    where: AuditEventScalarWhereInput
    data: XOR<AuditEventUpdateManyMutationInput, AuditEventUncheckedUpdateManyWithoutActorInput>
  }

  export type AuditEventScalarWhereInput = {
    AND?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
    OR?: AuditEventScalarWhereInput[]
    NOT?: AuditEventScalarWhereInput | AuditEventScalarWhereInput[]
    id?: StringFilter<"AuditEvent"> | string
    actorId?: StringNullableFilter<"AuditEvent"> | string | null
    action?: StringFilter<"AuditEvent"> | string
    target?: StringNullableFilter<"AuditEvent"> | string | null
    meta?: JsonNullableFilter<"AuditEvent">
    createdAt?: DateTimeFilter<"AuditEvent"> | Date | string
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    uploads?: UploadAssetCreateNestedManyWithoutUploaderInput
    pagesCreated?: PageCreateNestedManyWithoutCreatedByInput
    pagesUpdated?: PageCreateNestedManyWithoutUpdatedByInput
    auditEvents?: AuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    uploads?: UploadAssetUncheckedCreateNestedManyWithoutUploaderInput
    pagesCreated?: PageUncheckedCreateNestedManyWithoutCreatedByInput
    pagesUpdated?: PageUncheckedCreateNestedManyWithoutUpdatedByInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploads?: UploadAssetUpdateManyWithoutUploaderNestedInput
    pagesCreated?: PageUpdateManyWithoutCreatedByNestedInput
    pagesUpdated?: PageUpdateManyWithoutUpdatedByNestedInput
    auditEvents?: AuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    uploads?: UploadAssetUncheckedUpdateManyWithoutUploaderNestedInput
    pagesCreated?: PageUncheckedUpdateManyWithoutCreatedByNestedInput
    pagesUpdated?: PageUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutPagesCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    uploads?: UploadAssetCreateNestedManyWithoutUploaderInput
    pagesUpdated?: PageCreateNestedManyWithoutUpdatedByInput
    auditEvents?: AuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutPagesCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    uploads?: UploadAssetUncheckedCreateNestedManyWithoutUploaderInput
    pagesUpdated?: PageUncheckedCreateNestedManyWithoutUpdatedByInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutPagesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPagesCreatedInput, UserUncheckedCreateWithoutPagesCreatedInput>
  }

  export type UserCreateWithoutPagesUpdatedInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    uploads?: UploadAssetCreateNestedManyWithoutUploaderInput
    pagesCreated?: PageCreateNestedManyWithoutCreatedByInput
    auditEvents?: AuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutPagesUpdatedInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    uploads?: UploadAssetUncheckedCreateNestedManyWithoutUploaderInput
    pagesCreated?: PageUncheckedCreateNestedManyWithoutCreatedByInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutPagesUpdatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPagesUpdatedInput, UserUncheckedCreateWithoutPagesUpdatedInput>
  }

  export type UserUpsertWithoutPagesCreatedInput = {
    update: XOR<UserUpdateWithoutPagesCreatedInput, UserUncheckedUpdateWithoutPagesCreatedInput>
    create: XOR<UserCreateWithoutPagesCreatedInput, UserUncheckedCreateWithoutPagesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPagesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPagesCreatedInput, UserUncheckedUpdateWithoutPagesCreatedInput>
  }

  export type UserUpdateWithoutPagesCreatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    uploads?: UploadAssetUpdateManyWithoutUploaderNestedInput
    pagesUpdated?: PageUpdateManyWithoutUpdatedByNestedInput
    auditEvents?: AuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutPagesCreatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    uploads?: UploadAssetUncheckedUpdateManyWithoutUploaderNestedInput
    pagesUpdated?: PageUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserUpsertWithoutPagesUpdatedInput = {
    update: XOR<UserUpdateWithoutPagesUpdatedInput, UserUncheckedUpdateWithoutPagesUpdatedInput>
    create: XOR<UserCreateWithoutPagesUpdatedInput, UserUncheckedCreateWithoutPagesUpdatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPagesUpdatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPagesUpdatedInput, UserUncheckedUpdateWithoutPagesUpdatedInput>
  }

  export type UserUpdateWithoutPagesUpdatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    uploads?: UploadAssetUpdateManyWithoutUploaderNestedInput
    pagesCreated?: PageUpdateManyWithoutCreatedByNestedInput
    auditEvents?: AuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutPagesUpdatedInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    uploads?: UploadAssetUncheckedUpdateManyWithoutUploaderNestedInput
    pagesCreated?: PageUncheckedUpdateManyWithoutCreatedByNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type UserCreateWithoutUploadsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    pagesCreated?: PageCreateNestedManyWithoutCreatedByInput
    pagesUpdated?: PageCreateNestedManyWithoutUpdatedByInput
    auditEvents?: AuditEventCreateNestedManyWithoutActorInput
  }

  export type UserUncheckedCreateWithoutUploadsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    pagesCreated?: PageUncheckedCreateNestedManyWithoutCreatedByInput
    pagesUpdated?: PageUncheckedCreateNestedManyWithoutUpdatedByInput
    auditEvents?: AuditEventUncheckedCreateNestedManyWithoutActorInput
  }

  export type UserCreateOrConnectWithoutUploadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
  }

  export type UserUpsertWithoutUploadsInput = {
    update: XOR<UserUpdateWithoutUploadsInput, UserUncheckedUpdateWithoutUploadsInput>
    create: XOR<UserCreateWithoutUploadsInput, UserUncheckedCreateWithoutUploadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUploadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUploadsInput, UserUncheckedUpdateWithoutUploadsInput>
  }

  export type UserUpdateWithoutUploadsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    pagesCreated?: PageUpdateManyWithoutCreatedByNestedInput
    pagesUpdated?: PageUpdateManyWithoutUpdatedByNestedInput
    auditEvents?: AuditEventUpdateManyWithoutActorNestedInput
  }

  export type UserUncheckedUpdateWithoutUploadsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    pagesCreated?: PageUncheckedUpdateManyWithoutCreatedByNestedInput
    pagesUpdated?: PageUncheckedUpdateManyWithoutUpdatedByNestedInput
    auditEvents?: AuditEventUncheckedUpdateManyWithoutActorNestedInput
  }

  export type ReportCreateWithoutInstallationInput = {
    id?: string
    reportType: string
    notes?: string | null
    uploadObjectKey: string
    createdAt?: Date | string
  }

  export type ReportUncheckedCreateWithoutInstallationInput = {
    id?: string
    reportType: string
    notes?: string | null
    uploadObjectKey: string
    createdAt?: Date | string
  }

  export type ReportCreateOrConnectWithoutInstallationInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutInstallationInput, ReportUncheckedCreateWithoutInstallationInput>
  }

  export type ReportCreateManyInstallationInputEnvelope = {
    data: ReportCreateManyInstallationInput | ReportCreateManyInstallationInput[]
  }

  export type ReportUpsertWithWhereUniqueWithoutInstallationInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutInstallationInput, ReportUncheckedUpdateWithoutInstallationInput>
    create: XOR<ReportCreateWithoutInstallationInput, ReportUncheckedCreateWithoutInstallationInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutInstallationInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutInstallationInput, ReportUncheckedUpdateWithoutInstallationInput>
  }

  export type ReportUpdateManyWithWhereWithoutInstallationInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutInstallationInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: StringFilter<"Report"> | string
    installationId?: StringFilter<"Report"> | string
    reportType?: StringFilter<"Report"> | string
    notes?: StringNullableFilter<"Report"> | string | null
    uploadObjectKey?: StringFilter<"Report"> | string
    createdAt?: DateTimeFilter<"Report"> | Date | string
  }

  export type InstallationCreateWithoutReportsInput = {
    id?: string
    dealerId?: string | null
    siteName: string
    address?: InputJsonValue | null
    customerInfo?: InputJsonValue | null
    scheduledAt?: Date | string | null
    status?: $Enums.InstallStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallationUncheckedCreateWithoutReportsInput = {
    id?: string
    dealerId?: string | null
    siteName: string
    address?: InputJsonValue | null
    customerInfo?: InputJsonValue | null
    scheduledAt?: Date | string | null
    status?: $Enums.InstallStatus
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstallationCreateOrConnectWithoutReportsInput = {
    where: InstallationWhereUniqueInput
    create: XOR<InstallationCreateWithoutReportsInput, InstallationUncheckedCreateWithoutReportsInput>
  }

  export type InstallationUpsertWithoutReportsInput = {
    update: XOR<InstallationUpdateWithoutReportsInput, InstallationUncheckedUpdateWithoutReportsInput>
    create: XOR<InstallationCreateWithoutReportsInput, InstallationUncheckedCreateWithoutReportsInput>
    where?: InstallationWhereInput
  }

  export type InstallationUpdateToOneWithWhereWithoutReportsInput = {
    where?: InstallationWhereInput
    data: XOR<InstallationUpdateWithoutReportsInput, InstallationUncheckedUpdateWithoutReportsInput>
  }

  export type InstallationUpdateWithoutReportsInput = {
    dealerId?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: StringFieldUpdateOperationsInput | string
    address?: InputJsonValue | InputJsonValue | null
    customerInfo?: InputJsonValue | InputJsonValue | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInstallStatusFieldUpdateOperationsInput | $Enums.InstallStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstallationUncheckedUpdateWithoutReportsInput = {
    dealerId?: NullableStringFieldUpdateOperationsInput | string | null
    siteName?: StringFieldUpdateOperationsInput | string
    address?: InputJsonValue | InputJsonValue | null
    customerInfo?: InputJsonValue | InputJsonValue | null
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumInstallStatusFieldUpdateOperationsInput | $Enums.InstallStatus
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAuditEventsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionCreateNestedManyWithoutUserInput
    uploads?: UploadAssetCreateNestedManyWithoutUploaderInput
    pagesCreated?: PageCreateNestedManyWithoutCreatedByInput
    pagesUpdated?: PageCreateNestedManyWithoutUpdatedByInput
  }

  export type UserUncheckedCreateWithoutAuditEventsInput = {
    id?: string
    email: string
    passwordHash: string
    displayName: string
    roles?: UserCreaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    uploads?: UploadAssetUncheckedCreateNestedManyWithoutUploaderInput
    pagesCreated?: PageUncheckedCreateNestedManyWithoutCreatedByInput
    pagesUpdated?: PageUncheckedCreateNestedManyWithoutUpdatedByInput
  }

  export type UserCreateOrConnectWithoutAuditEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
  }

  export type UserUpsertWithoutAuditEventsInput = {
    update: XOR<UserUpdateWithoutAuditEventsInput, UserUncheckedUpdateWithoutAuditEventsInput>
    create: XOR<UserCreateWithoutAuditEventsInput, UserUncheckedCreateWithoutAuditEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditEventsInput, UserUncheckedUpdateWithoutAuditEventsInput>
  }

  export type UserUpdateWithoutAuditEventsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUpdateManyWithoutUserNestedInput
    uploads?: UploadAssetUpdateManyWithoutUploaderNestedInput
    pagesCreated?: PageUpdateManyWithoutCreatedByNestedInput
    pagesUpdated?: PageUpdateManyWithoutUpdatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditEventsInput = {
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    roles?: UserUpdaterolesInput | $Enums.Role[]
    profile?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    uploads?: UploadAssetUncheckedUpdateManyWithoutUploaderNestedInput
    pagesCreated?: PageUncheckedUpdateManyWithoutCreatedByNestedInput
    pagesUpdated?: PageUncheckedUpdateManyWithoutUpdatedByNestedInput
  }

  export type SessionCreateManyUserInput = {
    id?: string
    refreshToken: string
    userAgent?: string | null
    ip?: string | null
    createdAt?: Date | string
    revokedAt?: Date | string | null
  }

  export type UploadAssetCreateManyUploaderInput = {
    id?: string
    objectKey: string
    contentType: string
    size: number
    publicUrl?: string | null
    context?: string | null
    createdAt?: Date | string
  }

  export type PageCreateManyCreatedByInput = {
    id?: string
    title: string
    slug: string
    body: string
    status?: $Enums.PageStatus
    meta?: InputJsonValue | null
    updatedById?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PageCreateManyUpdatedByInput = {
    id?: string
    title: string
    slug: string
    body: string
    status?: $Enums.PageStatus
    meta?: InputJsonValue | null
    createdById: string
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditEventCreateManyActorInput = {
    id?: string
    action: string
    target?: string | null
    meta?: InputJsonValue | null
    createdAt?: Date | string
  }

  export type SessionUpdateWithoutUserInput = {
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    refreshToken?: StringFieldUpdateOperationsInput | string
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UploadAssetUpdateWithoutUploaderInput = {
    objectKey?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadAssetUncheckedUpdateWithoutUploaderInput = {
    objectKey?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UploadAssetUncheckedUpdateManyWithoutUploaderInput = {
    objectKey?: StringFieldUpdateOperationsInput | string
    contentType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    publicUrl?: NullableStringFieldUpdateOperationsInput | string | null
    context?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUpdateWithoutCreatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumPageStatusFieldUpdateOperationsInput | $Enums.PageStatus
    meta?: InputJsonValue | InputJsonValue | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedBy?: UserUpdateOneWithoutPagesUpdatedNestedInput
  }

  export type PageUncheckedUpdateWithoutCreatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumPageStatusFieldUpdateOperationsInput | $Enums.PageStatus
    meta?: InputJsonValue | InputJsonValue | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateManyWithoutCreatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumPageStatusFieldUpdateOperationsInput | $Enums.PageStatus
    meta?: InputJsonValue | InputJsonValue | null
    updatedById?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUpdateWithoutUpdatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumPageStatusFieldUpdateOperationsInput | $Enums.PageStatus
    meta?: InputJsonValue | InputJsonValue | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutPagesCreatedNestedInput
  }

  export type PageUncheckedUpdateWithoutUpdatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumPageStatusFieldUpdateOperationsInput | $Enums.PageStatus
    meta?: InputJsonValue | InputJsonValue | null
    createdById?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageUncheckedUpdateManyWithoutUpdatedByInput = {
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    status?: EnumPageStatusFieldUpdateOperationsInput | $Enums.PageStatus
    meta?: InputJsonValue | InputJsonValue | null
    createdById?: StringFieldUpdateOperationsInput | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUpdateWithoutActorInput = {
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateWithoutActorInput = {
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditEventUncheckedUpdateManyWithoutActorInput = {
    action?: StringFieldUpdateOperationsInput | string
    target?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: InputJsonValue | InputJsonValue | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateManyInstallationInput = {
    id?: string
    reportType: string
    notes?: string | null
    uploadObjectKey: string
    createdAt?: Date | string
  }

  export type ReportUpdateWithoutInstallationInput = {
    reportType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadObjectKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateWithoutInstallationInput = {
    reportType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadObjectKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportUncheckedUpdateManyWithoutInstallationInput = {
    reportType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    uploadObjectKey?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstallationCountOutputTypeDefaultArgs instead
     */
    export type InstallationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstallationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SessionDefaultArgs instead
     */
    export type SessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PageDefaultArgs instead
     */
    export type PageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PageDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UploadAssetDefaultArgs instead
     */
    export type UploadAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UploadAssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InstallationDefaultArgs instead
     */
    export type InstallationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InstallationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditEventDefaultArgs instead
     */
    export type AuditEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeadDefaultArgs instead
     */
    export type LeadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealerDefaultArgs instead
     */
    export type DealerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FileAssetDefaultArgs instead
     */
    export type FileAssetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FileAssetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DealerUploadDefaultArgs instead
     */
    export type DealerUploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DealerUploadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingEventDefaultArgs instead
     */
    export type TrainingEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingRegistrationDefaultArgs instead
     */
    export type TrainingRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingRegistrationDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}